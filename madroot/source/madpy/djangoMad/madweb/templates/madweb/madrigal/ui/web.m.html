{% load static %}

<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>madrigal.ui.web API documentation</title>
    <meta name="description" content="web is the module that interfaces to cgi madrigal web pages.

The web module contains general functi..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>

  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>

  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
  <link href="/static/madrigal.css" rel="stylesheet" type="text/css" />
<style type="text/css">
	html body {
		background-color: {{bg_color}};
	}
</style>
</head>
<body>
<table width="100%" border="1" cellpadding="0" cellspacing="2" class="navigation">
  <tr>
    <td width="5%"><a href="userData.m.html"><img src="/static/previous.png" alt="previous" width="32" height="32" border="0" /></a></td>
    <td width="5%"><a href="index.html"><img src="/static/up.png" alt="up" width="32" height="32" /></a></td>
    <td width="5%"><a href="../../dev_derivation.html"><img src="/static/next.png" alt="next" width="32" height="32" /></a></td>
    <td width="54%">madrigal.ui.web</td>
    <td width="13%"><a href="../../madContents.html">Doc home </a></td>
    <td width="18%"><a href="/">Madrigal home</a></td>
  </tr>
</table>
<div class='online-navigation'>
<b class="navlabel">Previous:</b>
<a class="sectref" href="userData.m.html">madrigal.ui.userData </A>
<b class="navlabel">&nbsp;&nbsp;Up:</b>
<a class="sectref" href="index.html">madrigal.ui</A>
<b class="navlabel">&nbsp;&nbsp;Next:</b>
<a class="sectref" href="../../dev_derivation.html">Madrigal derivation engine</A></div>
<hr/>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#madrigal.ui.web.MadrigalWeb">MadrigalWeb</a></span>
        
          
  <ul>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.__init__">__init__</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.cleanStage">cleanStage</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.createGlobalDownloadCmd">createGlobalDownloadCmd</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.createGlobalIsprintCmd">createGlobalIsprintCmd</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.downloadFileAsIs">downloadFileAsIs</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.downloadFullFileAsIs">downloadFullFileAsIs</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.downloadIsprintFileFromIsprintForm">downloadIsprintFileFromIsprintForm</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.downloadMultipleFiles">downloadMultipleFiles</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.filterLog">filterLog</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.generateDownloadFileScriptFromForm">generateDownloadFileScriptFromForm</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.generateGlobalIsprintScriptFromForm">generateGlobalIsprintScriptFromForm</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.generateLogout">generateLogout</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.getDays">getDays</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.getExpIDFromExpPath">getExpIDFromExpPath</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.getExpInfoFromExpID">getExpInfoFromExpID</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.getExperimentList">getExperimentList</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.getExpsOnDate">getExpsOnDate</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.getFileFromExpDir">getFileFromExpDir</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.getFileFromExpID">getFileFromExpID</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.getInfoFromFile">getInfoFromFile</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.getMonths">getMonths</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.getRulesOfTheRoad">getRulesOfTheRoad</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.getSingleRedirectList">getSingleRedirectList</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.getSiteInfo">getSiteInfo</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.isTrusted">isTrusted</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.listRecords">listRecords</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.logDataAccess">logDataAccess</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.modifyBasename">modifyBasename</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.printFileAsIs">printFileAsIs</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.runLookerFromForm">runLookerFromForm</a></li>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWeb.runMadrigalCalculatorFromForm">runMadrigalCalculatorFromForm</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#madrigal.ui.web.MadrigalWebFormat">MadrigalWebFormat</a></span>
        
          
  <ul>
    <li class="mono"><a href="#madrigal.ui.web.MadrigalWebFormat.getFormat">getFormat</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">madrigal.ui.web</span> module</h1>
  <p>web is the module that interfaces to cgi madrigal web pages.</p>
<p>The web module contains general functions to produce html, along with producing
html relating to specific user data or madrigal data.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web" class="source">
    <pre><code>"""web is the module that interfaces to cgi madrigal web pages.

The web module contains general functions to produce html, along with producing
html relating to specific user data or madrigal data.
"""

# $Id: web.py 7043 2019-10-07 19:10:59Z brideout $

import time, os
import os.path
import calendar
import fnmatch
import datetime
import types, traceback
import http.cookies
import urllib.request, urllib.parse, urllib.error
import glob
import calendar
import urllib.parse
import math
import random
import tempfile
import subprocess
import tarfile
import shutil
import re

# third party imports
import numpy
import django.urls

import madrigal.metadata
import madrigal.derivation
import madrigal.data
import madrigal.isprint
import madrigal.ui.userData
import madrigal.admin

class MadrigalWeb:
    """MadrigalWeb is the class that produces output for the web.

    All text written to the web is produced in this class.

    Non-standard Python modules used:
    None

    Change history:

    Written by "Bill Rideout":mailto:wrideout@haystack.mit.edu  Dec. 17, 2001
    """
    

    _MaxSleep     = 10

    def __init__(self, madDB = None):
        """__init__ initializes MadrigalWeb by reading from MadridalDB..

        Inputs: Existing MadrigalDB object, by default = None.
        
        Returns: void

        Affects: Initializes self._metaDir, self._logFile.

        Exceptions: None.
        """

        if madDB == None:
            self._madDB = madrigal.metadata.MadrigalDB()
        else:
            self._madDB = madDB

        self._binDir = self._madDB.getBinDir()
        self._instObj = madrigal.metadata.MadrigalInstrument(self._madDB)
        self._madKindatObj = madrigal.metadata.MadrigalKindat(self._madDB)

        metaDir = self._madDB.getMetadataDir()

        # get todays year
        now = datetime.datetime.now()

        thisYear = '%04i' % (now.year)

        self._logFile = os.path.join(metaDir, 'userdata', 'access_%s.log' % (thisYear))

        # be sure it exists
        if not os.access(self._logFile, os.R_OK):
            f=open(self._logFile, 'w')
            f.close()

        # keep track of whether user trusted
        self._isTrusted_ = None
        
        # cache Madrigal objects as needed to imprive performance
        self._madExpObjExpID = None # will be set to a MadrigalExperiment object sorted by expId when first needed
        self._madExpObjDate = None # will be set to a MadrigalExperiment object sorted by date when first needed




    def getRulesOfTheRoad(self, PI=None, PIEmail=None):
        """ getRulesOfTheRoad returns a string giving the rules in html formal for using madrigal data.

        Inputs: PI - contact name. Default is site name.
            PIEmail - email link.  Default is site admin.
        
        Returns: a string giving the rules in html formal for using madrigal data

        Affects: None.

        Exceptions: None.
        """
        if not PI or not PIEmail:
            # get the site name
            siteObj = madrigal.metadata.MadrigalSite(self._madDB)
            siteID = self._madDB.getSiteID()
            contactName = str(siteObj.getSiteName(siteID))
            contactEmail = str(siteObj.getSiteEmail(siteID))
        else:
            contactName = str(PI)
            contactEmail = str(PIEmail)
        
        returnStr = 'Please contact %s at ' % (contactName)

        returnStr = returnStr + '<a href="mailto:' + contactEmail + '">' + \
                    contactEmail + '</a> before using this data in a report or publication.'

        return returnStr
    
        
    def generateLogout(self, fileName, expName):
        """ generateLogout generates a java script which sends a user to the madLogin page to logout automatically.

        Inputs: fileName: the madrigal file to return to
                expName:  the experiment name of the file to return to
        
        Returns: a java script which sends a user to the madLogin page to logout automatically

        Affects: None.

        Exceptions: None.
        """

        print('<script language = "JavaScript">')
        print('\twindow.location = "madLogin?fileName=' + \
              fileName + '&expName=' + \
              expName + '&state=autoLogout"')
        print('</script>')


    def isTrusted(self):
        """ isTrusted returns 1 if browser ip matches any in the trustedIPs.txt file; 0 otherwise.

        Inputs: None
        
        Returns: 1 if browser ip matches any in the trustedIPs.txt file; 0 otherwise.  Also returns
        0 if no browser ip available or trustedIPs.txt cannot be opened.

        Affects: None.

        Exceptions: None.
        """
        if self._isTrusted_ != None:
            return(self._isTrusted_)
        
        try:
            trustFile = open(self._madDB.getMadroot() + '/trustedIPs.txt', 'r')
        except:
            return 0

        # try to read env var REMOTE_ADDR and HTTP_X_FORWARDED_FOR
        userIPList = []
        if os.environ.get('REMOTE_ADDR')!= None:
            userIPList.append(os.environ.get('REMOTE_ADDR'))
        if os.environ.get('HTTP_X_FORWARDED_FOR') != None:
            ips = os.environ.get('HTTP_X_FORWARDED_FOR').split(',')
            for ip in ips:
                userIPList.append(ip.strip())
        if len(userIPList) == 0:
            self._isTrusted_ = 0
            return 0
        if len(userIPList[0]) < 7:
            # ip address too short
            self._isTrusted_ = 0
            return 0

        # loop through trustedIPs.txt to find a match
        ipList = trustFile.readlines()
        for userIP in userIPList:
            for ipItem in ipList:
                # match using filename matching with *
                if fnmatch.fnmatch(userIP, ipItem.strip()):
                    self._isTrusted_ = 1
                    return 1

        # out of loop, no match found
        self._isTrusted_ = 0
        return 0


    def logDataAccess(self, fullFilenameList, user_fullname=None, user_email=None, user_affiliation=None):
        """ logDataAccess logs queries that access low-level data.

        Records user name, email, affiliation, datetime, and full path the file(s) accessed.

        Inputs:

            fullFilenameList either a list of full filenames, or a string with one filename

            user_fullname - if None, try to read from cookie.  Also, any commas replaced by spaces.

            user_email - if None, try to read from cookie.  Also, any commas replaced by spaces.

            user_affiliation - if None, try to read from cookie.  Also, any commas replaced by spaces.
            

        Outputs: None

        Affects: Write line to log file with 5 or more comma-delimited columns.  Example:

            Bill Rideout,brideout@haystack.mit.edu,MIT Haystack,2002-12-25 00:00:00, \
            /opt/madrigal/experiments/2005/mlh/01sep05/mlh050901g.001,/opt/madrigal/experiments/2005/mlh/02sep05/mlh050902g.001

        Uses _getLock and _dropLock to ensure single users access to log file
        """

        if user_fullname == None or user_email == None or user_affiliation == None:
        
            # try to get name, email, affiliation from cookie
            cookie = http.cookies.SimpleCookie()
            if 'HTTP_COOKIE' in os.environ:
                cookie.load(os.environ['HTTP_COOKIE'])
                try:
                    user_fullname = cookie["user_fullname"].value
                    user_email = cookie["user_email"].value
                    user_affiliation = cookie["user_affiliation"].value
                except:
                    # no way to write log
                    return

            if user_fullname == None or user_email == None or user_affiliation == None:
                return

        # strip out any commas
        user_fullname = user_fullname.replace(',', ' ')
        user_email = user_email.replace(',', ' ')
        user_affiliation = user_affiliation.replace(',', ' ')

        if type(fullFilenameList) in (list, tuple):
            delimiter = ','
            fileStr = delimiter.join(fullFilenameList)
        else:
            fileStr = str(fullFilenameList)
        

        now = datetime.datetime.now()


        nowStr = now.strftime('%Y-%m-%d %H-%M-%S')

        # lock out any method that writes to log file
        self._getLock(self._logFile)

        f = open(self._logFile, 'a')

        f.write('%s,%s,%s,%s,%s\n' % (user_fullname.encode('utf8'),
                                      user_email.encode('utf8'),
                                      user_affiliation.encode('utf8'),
                                      nowStr,
                                      fileStr))



        f.close()

        # done with log file - allow access to other writing calls
        self._dropLock(self._logFile)  
        
        
    def filterLog(self, tmpFile, kinstList=None, accessStartDate=None, accessEndDate=None):
        """filterLog writes a subsection of the access log to a temporary file
        
        Inputs:
        
            tmpFile - temporary file to write subsection of log to
            
            kinstList - list of kinsts to accept.  If None (the default), accept all instruments
            
            accessStartDate - if not None (the default), reject all access dates before
                datetime accessStartDate
                
            accessEndDate - if not None (the default), reject all access dates after
                datetime accessEndDate
            
        """
        f = open(tmpFile, 'w')
        
        accessLogs = glob.glob(os.path.join(self._madDB.getMadroot(), 'metadata/userdata/access_*.log'))
        accessLogs.sort()
        
        # addition for cedar only
        """accessLogs2 = glob.glob('/opt/cedar/metadata/userdata/access_*[0-9].log')
        accessLogs += accessLogs2
        accessLogs.sort()"""
        
        
        if kinstList:
            # create a dictionary of key = 3 letter inst mnem, value = kinstList
            instDict = {}
            instList = self._instObj.getInstrumentList()
            for inst in instList:
                if inst[1] in instDict:
                    instDict[inst[1]].append(inst[2])
                else:
                    instDict[inst[1]] = [inst[2]]
        
        for accessLog in accessLogs:
            # see if we can skip this year
            basename = os.path.basename(accessLog)
            year = int(basename[7:-4])
            startYear = datetime.datetime(year,1,1,0,0,0)
            endYear = datetime.datetime(year,12,31,23,59,59)
            if accessStartDate:
                if accessStartDate > endYear:
                    continue
            if accessEndDate:
                if accessEndDate < startYear:
                    continue
            # this file can be huge, so read one line at a time
            fl = open(accessLog)
            while True:
                line = fl.readline()
                if len(line) == 0:
                    break
                items = line.strip().split(',')
                if len(items) != 5:
                    continue
                # walk through filters
                
                # kinst
                if kinstList:
                    # get the instrument mnemonic
                    dirs = items[-1].split('/')
                    found = False
                    try:
                        for kinst in instDict[dirs[-3]]:
                            if kinst in kinstList:
                                found = True
                                break
                    except KeyError:
                        continue
                    if not found:
                        continue
                    
                # access time
                if accessStartDate or accessEndDate:
                    thisDT = datetime.datetime.strptime(items[-2], '%Y-%m-%d %H-%M-%S')
                    if accessStartDate:
                        if accessStartDate > thisDT:
                            continue
                    if accessEndDate:
                        if accessEndDate < thisDT:
                            continue
                        
                # all filters passed
                f.write(line)
                
            fl.close()
                
        f.close()
                
                    
                
        
    def createGlobalIsprintCmd(self, language, madrigalUrl, parmList, output,
                               user_fullname, user_email, user_affiliation,
                               start_datetime, end_datetime, instCode,
                               filterList, kindatList, expName, fileDesc,
                               seasonalStartDate, seasonalEndDate, format=None):
        """createGlobalIsprintCmd returns a string representing a global isprint command to run in a particular language.
        
        Inputs:
        
            language - which language to use.  Allowed values are ('python', 'Matlab', 'IDL')
            madrigalUrl - url to madrigal home page where data is
            parmList - ordered list of parameters requested.
            output - output file name
            user_fullname
            user_email
            user_affiliation
            start_datetime - a datetime object. Reject experiments before that datetime
            end_datetime - a datetime object. Reject experiments after that datetime
            instCode - instrument code (integer)
            filterList - a list of strings in form "mnem,lower,upper" where lower and/or upper may be empty
            kindatList - a list of kindat codes.  An empty list selects all kindats
            expName - filter experiments by the experiment name. Matching is case insensitive and fnmatch characters * and ? are allowed. 
                Empty string is no filtering by experiment name.
            fileDesc - filter files by the file description string. Matching is case insensitive and fnmatch characters * and ? are allowed. 
                Empty string is no filtering by file description.
            seasonalStartDate - a string in form 'MM/DD'.  Dates before then in any year will be ignored.  Assumes non-leap year.
                Empty string means no filtering by seasonal start date.
            seasonalEndDate - a string in form 'MM/DD'.  Dates after then in any year will be ignored.  Assumes non-leap year.
                Empty string means no filtering by seasonal end date.
            format - 'hdf5', 'ascii', or 'netCDF4'. If None, not specified (Madrigal 2 does not support this)
        """
        if language not in ('python', 'Matlab', 'IDL'):
            raise ValueError('language %s not supported' % (str(language)))
        
        # url
        if language == 'python':
            cmd = 'globalIsprint.py --verbose --url=%s ' % (madrigalUrl)
        elif language == 'Matlab':
            cmd = "globalIsprint('%s', ...\n " % (madrigalUrl)
        elif language == 'IDL':
            cmd = "madglobalprint, '%s',  $\n " % (madrigalUrl)
            
        # parms
        if len(parmList) == 0:
            raise ValueError('parmList cannot be empty')
        parmStr = ''
        for parm in parmList:
            parmStr += str(parm)
            if parm != parmList[-1]:
                parmStr += ','
        if language == 'python':
            cmd += '--parms=%s ' % (parmStr)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (parmStr)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (parmStr)
            
        # output
        if language == 'python':
            cmd += '--output=%s ' % (output)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (output)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (output)
            
        # user_fullname
        if language == 'python':
            cmd += '--user_fullname="%s" ' % (user_fullname)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (user_fullname)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (user_fullname)
            
        # user_email
        if language == 'python':
            cmd += '--user_email=%s ' % (user_email)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (user_email)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (user_email)
            
        # user_affiliation
        if language == 'python':
            cmd += '--user_affiliation="%s" ' % (user_affiliation)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (user_affiliation)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (user_affiliation)
            
        
        # start_datetime
        if language == 'python':
            cmd += '--startDate="%s" ' % (start_datetime.strftime('%m/%d/%Y'))
        elif language == 'Matlab':
            cmd += "datenum('%s'), ...\n " % (start_datetime.strftime('%d-%b-%Y %H:%M:%S'))
        elif language == 'IDL':
            cmd += "julday(%i,%i,%i,%i,%i,%i),  $\n " % (start_datetime.month, start_datetime.day,
                                                          start_datetime.year, start_datetime.hour,
                                                          start_datetime.minute, start_datetime.second)
            
        # end_datetime
        if language == 'python':
            cmd += '--endDate="%s" ' % (end_datetime.strftime('%m/%d/%Y'))
        elif language == 'Matlab':
            cmd += "datenum('%s'), ...\n " % (end_datetime.strftime('%d-%b-%Y %H:%M:%S'))
        elif language == 'IDL':
            cmd += "julday(%i,%i,%i,%i,%i,%i),  $\n " % (end_datetime.month, end_datetime.day,
                                                          end_datetime.year, end_datetime.hour,
                                                          end_datetime.minute, end_datetime.second)
            
        # instrument
        if language == 'python':
            cmd += '--inst=%i ' % (instCode)
        elif language == 'Matlab':
            cmd += "%i, ...\n " % (instCode)
        elif language == 'IDL':
            cmd += "%i,  $\n " % (instCode)
            
        # format is here for Matlab or python
        if output == 'example.txt':
            format = None
        if language in ('Matlab', 'python'):
            if language == 'python':
                if not format is None:
                    if format.lower() == 'hdf5':
                        cmd += '--format=%s ' % ('Hdf5')
                    elif format in ('netCDF4', 'ascii'):
                        cmd += '--format=%s ' % (format)
            elif language == 'Matlab':
                if format is None:
                    cmd += "'', ...\n "
                elif format.lower() == 'hdf5':
                    cmd += "'%s', ...\n " % ('Hdf5')
                elif format in ('netCDF4', 'ascii'):
                    cmd += "'%s', ...\n " % (format)
            
        # filterList
        # add seasonal filters if needed 
        if len(seasonalStartDate) or len(seasonalEndDate):
            daynoFilterStr = self._getDaynoFilter(seasonalStartDate, seasonalEndDate)
            filterList.append(daynoFilterStr)
        if language == 'python':
            for filterItem in filterList:
                cmd += '--filter=%s ' % (filterItem)
        elif language == 'Matlab':
            filterStr = ''
            for filterItem in filterList:
                filterStr += 'filter=%s ' % (filterItem)
            cmd += "'%s', ...\n " % (filterStr)
        elif language == 'IDL':
            filterStr = ''
            for filterItem in filterList:
                filterStr += 'filter=%s ' % (filterItem)
            cmd += "'%s',  $\n " % (filterStr)
            
        # kindatList
        if language == 'python':
            if len(kindatList) == 0:
                pass
            else:
                kindatStr = '--kindat='
                for kindat in kindatList:
                    kindatStr += '%i' % (kindat)
                    if kindat != kindatList[-1]:
                        kindatStr += ','
                cmd += '%s ' % (kindatStr)
        elif language == 'Matlab':
            kindatStr = '['
            for kindat in kindatList:
                if kindat == 0:
                    continue
                kindatStr += '%i' % (kindat)
                if kindat != kindatList[-1]:
                    kindatStr += ','
            kindatStr += ']'
            cmd += "%s, ...\n " % (kindatStr)
        elif language == 'IDL':
            # make sure 0 not in list
            try:
                kindatList.remove(0)
            except ValueError:
                pass
            if len(kindatList) == 0:
                kindatStr = 'PTR_NEW()'
            else:
                kindatStr = '['
                for kindat in kindatList:
                    kindatStr += '%i' % (kindat)
                    if kindat != kindatList[-1]:
                        kindatStr += ','
                kindatStr += ']'
            cmd += "%s,  $\n " % (kindatStr)
            
        # expName
        if language == 'python':
            if len(expName) > 0:
                cmd += '--expName="%s" ' % (expName)
        elif language == 'Matlab':
            expName = expName.replace('*', '.*')
            expName = expName.replace('?', '.?')
            cmd += "'%s', ...\n " % (expName)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (expName)
            
        # fileDesc
        if language == 'python':
            if len(fileDesc) > 0:
                cmd += '--fileDesc="%s" ' % (fileDesc)
        elif language == 'Matlab':
            fileDesc = fileDesc.replace('*', '.*')
            fileDesc = fileDesc.replace('?', '.?')
            cmd += "'%s') " % (fileDesc)
        elif language == 'IDL':
            cmd += "'%s',  $\n "  % (fileDesc)
            
        # format is here for idl
        if language == 'IDL':
            if format is None:
                cmd += "'',  $\n "
            elif format.lower() == 'hdf5':
                cmd += "'hdf5',  $\n "
            elif format in ('netCDF4', 'ascii'):
                cmd += "'%s',  $\n "  % (format)
            
            
            
        return(cmd)
    
    
    
    def createGlobalDownloadCmd(self, language, madrigalUrl, output, format,
                               user_fullname, user_email, user_affiliation,
                               start_datetime, end_datetime, instCode,
                               kindatList, expName, fileDesc):
        """createGlobalDownloadCmd returns a string representing a global download as is command to run in a particular language.
        
        Inputs:
        
            language - which language to use.  Allowed values are ('python', 'Matlab', 'IDL')
            madrigalUrl - url to madrigal home page where data is
            output - output directory name
            format - 'hdf5', 'ascii', or 'netCDF4'
            user_fullname
            user_email
            user_affiliation
            start_datetime - a datetime object. Reject experiments before that datetime
            end_datetime - a datetime object. Reject experiments after that datetime
            instCode - instrument code (integer)
            kindatList - a list of kindat codes.  An empty list selects all kindats
            expName - filter experiments by the experiment name. Matching is case insensitive and fnmatch characters * and ? are allowed. 
                Empty string is no filtering by experiment name.
            fileDesc - filter files by the file description string. Matching is case insensitive and fnmatch characters * and ? are allowed. 
                Empty string is no filtering by file description.
        """
        if language not in ('python', 'Matlab', 'IDL'):
            raise ValueError('language %s not supported' % (str(language)))
        
        # url
        if language == 'python':
            cmd = 'globalDownload.py --verbose --url=%s ' % (madrigalUrl)
        elif language == 'Matlab':
            cmd = "globalDownload('%s', ...\n " % (madrigalUrl)
        elif language == 'IDL':
            cmd = "madglobaldownload, '%s',  $\n " % (madrigalUrl)
            
        # output
        if language == 'python':
            cmd += '--outputDir=%s ' % (output)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (output)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (output)
            
        # user_fullname
        if language == 'python':
            cmd += '--user_fullname="%s" ' % (user_fullname)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (user_fullname)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (user_fullname)
            
        # user_email
        if language == 'python':
            cmd += '--user_email=%s ' % (user_email)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (user_email)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (user_email)
            
        # user_affiliation
        if language == 'python':
            cmd += '--user_affiliation="%s" ' % (user_affiliation)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (user_affiliation)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (user_affiliation)
            
        # format part 1 (format is not in same order in Matlab and IDL)
        if format not in ('hdf5', 'ascii', 'netCDF4'):
            raise ValueError('format not in hdf5, ascii or netCDF4')
        if language == 'python':
            cmd += '--format="%s" ' % (format)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (format)
        
        # start_datetime
        if language == 'python':
            cmd += '--startDate="%s" ' % (start_datetime.strftime('%m/%d/%Y'))
        elif language == 'Matlab':
            cmd += "datenum('%s'), ...\n " % (start_datetime.strftime('%d-%b-%Y %H:%M:%S'))
        elif language == 'IDL':
            cmd += "julday(%i,%i,%i,%i,%i,%i),  $\n " % (start_datetime.month, start_datetime.day,
                                                          start_datetime.year, start_datetime.hour,
                                                          start_datetime.minute, start_datetime.second)
            
        # end_datetime
        if language == 'python':
            cmd += '--endDate="%s" ' % (end_datetime.strftime('%m/%d/%Y'))
        elif language == 'Matlab':
            cmd += "datenum('%s'), ...\n " % (end_datetime.strftime('%d-%b-%Y %H:%M:%S'))
        elif language == 'IDL':
            cmd += "julday(%i,%i,%i,%i,%i,%i),  $\n " % (end_datetime.month, end_datetime.day,
                                                          end_datetime.year, end_datetime.hour,
                                                          end_datetime.minute, end_datetime.second)
            
        # instrument
        if language == 'python':
            cmd += '--inst=%i ' % (instCode)
        elif language == 'Matlab':
            cmd += "%i, ...\n " % (instCode)
        elif language == 'IDL':
            cmd += "%i,  $\n " % (instCode)
            
            
        # kindatList
        if language == 'python':
            if len(kindatList) == 0:
                pass
            else:
                kindatStr = '--kindat='
                for kindat in kindatList:
                    kindatStr += '%i' % (kindat)
                    if kindat != kindatList[-1]:
                        kindatStr += ','
                cmd += '%s ' % (kindatStr)
        elif language == 'Matlab':
            kindatStr = '['
            for kindat in kindatList:
                if kindat == 0:
                    continue
                kindatStr += '%i' % (kindat)
                if kindat != kindatList[-1]:
                    kindatStr += ','
            kindatStr += ']'
            cmd += "%s, ...\n " % (kindatStr)
        elif language == 'IDL':
            # make sure 0 not in list
            try:
                kindatList.remove(0)
            except ValueError:
                pass
            if len(kindatList) == 0:
                kindatStr = 'PTR_NEW()'
            else:
                kindatStr = '['
                for kindat in kindatList:
                    kindatStr += '%i' % (kindat)
                    if kindat != kindatList[-1]:
                        kindatStr += ','
                kindatStr += ']'
            cmd += "%s,  $\n " % (kindatStr)
            
            
        # now deal with IDL format if needed
        if language == 'IDL':
            cmd += "'%s',  $\n " % (format)
            
        # expName
        if language == 'python':
            if len(expName) > 0:
                cmd += '--expName="%s" ' % (expName)
        elif language == 'Matlab':
            expName = expName.replace('*', '.*')
            expName = expName.replace('?', '.?')
            cmd += "'%s', ...\n " % (expName)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (expName)
            
        # fileDesc
        if language == 'python':
            if len(fileDesc) > 0:
                cmd += '--fileDesc="%s" ' % (fileDesc)
        elif language == 'Matlab':
            fileDesc = fileDesc.replace('*', '.*')
            fileDesc = fileDesc.replace('?', '.?')
            cmd += "'%s') " % (fileDesc)
        elif language == 'IDL':
            cmd += "'%s' " % (fileDesc)
            
        return(cmd)
    
    
    def generateGlobalIsprintScriptFromForm(self, form1, form2, form3, user_fullname,
                                            user_email, user_affiliation):
        """generateGlobalIsprintScriptFromForm converts the three Django forms into arguments so that
        if can then call createGlobalIsprintCmd. Separate forms used because some parts are created by
        Ajax.
        
        form1 is a dict with keys:
            instruments, start_date, end_date, format_select, directory_select, language_select, kindat_select,
            expName, fileDesc, seasonalStartDay, seasonalStartMonth, seasonalEndDay, seasonalEndMonth
        form2 is a dict with keys parameters
        form3 is a dict with keys parm_#, parm_#_lower, parm_#_upper, where # is 1, 2, and 3
        user_fullname, user_email, user_affiliation - strings
            
        """
        instCode = int(form1['instruments'])
        start_datetime = datetime.datetime(form1['start_date'].year, form1['start_date'].month, form1['start_date'].day)
        end_datetime = datetime.datetime(form1['end_date'].year, form1['end_date'].month, form1['end_date'].day)
        format = form1['format_select']
        if format == 'ascii' and form1['directory_select'] == 'File':
            output = 'example.txt'
        else:
            output = '/tmp'
        language = form1['language_select']
        kindatList = [int(kindat) for kindat in form1['kindat_select']]
        expName = form1['expName'].strip()
        fileDesc = form1['fileDesc'].strip()
        seasonalStartDay = int(form1['seasonalStartDay'])
        seasonalStartMonth = int(form1['seasonalStartMonth'])
        seasonalEndDay = int(form1['seasonalEndDay'])
        seasonalEndMonth = int(form1['seasonalEndMonth'])
        if seasonalStartDay == 1 and seasonalStartMonth == 1 and \
            seasonalEndDay == 31 and seasonalEndMonth == 12:
            seasonalStartDate = ''
            seasonalEndDate = ''
        else:
            seasonalStartDate = '%02i/%02i' % (seasonalStartMonth, seasonalStartDay)
            seasonalEndDate = '%02i/%02i' % (seasonalEndMonth, seasonalStartDay)
        madrigalUrl = self._madDB.getTopLevelUrl()
        parmList = form2['parameters']
        filterList = []
        for i in (1,2,3):
            try:
                parm = form3['parm_%i' % (i)]
            except KeyError:
                continue
            if len(parm) == 0:
                continue
            filterStr = '%s,' % (parm)
            try:
                parm_lower = form3['parm_%i_lower' % (i)]
                filterStr += '%s,' % (str(parm_lower))
            except KeyError:
                filterStr += ','
            try:
                parm_upper = form3['parm_%i_upper' % (i)]
                filterStr += '%s' % (str(parm_upper))
            except KeyError:
                pass
            filterList.append(filterStr)
            
            
        return(self.createGlobalIsprintCmd(language, madrigalUrl, parmList, output,
                                           user_fullname, user_email, user_affiliation,
                                           start_datetime, end_datetime, instCode,
                                           filterList, kindatList, expName, fileDesc,
                                           seasonalStartDate, seasonalEndDate, format))
    
    
    def generateDownloadFileScriptFromForm(self, form, user_fullname,
                                           user_email, user_affiliation):
        """generateDownloadFileScriptFromForm converts the Django form into arguments so that
        if can then call createGlobalDownloadCmd.
        
        form is a dict with keys:
            instruments, start_date, end_date, format_select, language_select, kindat_select,
            expName, fileDesc
        user_fullname, user_email, user_affiliation - strings
            
        """
        instCode = int(form['instruments'])
        start_datetime = datetime.datetime(form['start_date'].year, form['start_date'].month, form['start_date'].day)
        end_datetime = datetime.datetime(form['end_date'].year, form['end_date'].month, form['end_date'].day)
        format = form['format_select']
        language = form['language_select']
        kindatList = [int(kindat) for kindat in form['kindat_select']]
        expName = form['expName'].strip()
        fileDesc = form['fileDesc'].strip()
        madrigalUrl = self._madDB.getTopLevelUrl()
        return(self.createGlobalDownloadCmd(language, madrigalUrl, '/tmp', format,
                               user_fullname, user_email, user_affiliation,
                               start_datetime, end_datetime, instCode,
                               kindatList, expName, fileDesc))
    
    
    def getSingleRedirectList(self):
        """getSingleRedirectList returns a list with tuples (kinst, url) where url is url to redirect single UI
        to if instrument not local. If no redirect needed because instrument local, url is empty string
        """
        madInstData = madrigal.metadata.MadrigalInstrumentData(self._madDB, True)
        siteObj = madrigal.metadata.MadrigalSite(self._madDB)
        siteID = self._madDB.getSiteID()
        
        # create a dict with key = siteID, value = redirect url for speed
        getStr = '?isGlobal=True&categories=%i&instruments=%i'
        addUrl = django.urls.reverse('view_single')
        cedarUrl = 'http://cedar.openmadrigal.org/' + addUrl + getStr
        siteDict = {}
        for thisSiteID, siteDesc in siteObj.getSiteList():
            if thisSiteID == siteID:
                siteDict[thisSiteID] = '' # local case
            elif siteObj.getSiteVersion(thisSiteID) == '2.6':
                # redirect to cedar because other site below Madrigal 3
                siteDict[thisSiteID] = cedarUrl
            else:
                siteDict[thisSiteID] = 'http://' + siteObj.getSiteServer(thisSiteID)
                secondPart = siteObj.getSiteDocRoot(thisSiteID) + addUrl + getStr
                if secondPart[0] == '/':
                    siteDict[thisSiteID] += secondPart
                else:
                    siteDict[thisSiteID] += '/' + secondPart
        
        
        retList = []
        for kinst, desc, thisSiteID in madInstData.getInstruments():
            if len(siteDict[thisSiteID]) > 0:
                if siteDict[thisSiteID].find('=%i') != -1:
                    url = siteDict[thisSiteID] % (self._instObj.getCategoryId(kinst), kinst)
                else:
                    url = siteDict[thisSiteID]
            else:
                url = ''
            retList.append((kinst, url))
            
        return(retList)
    
    
    def getMonths(self, kinst, year, optimize=True):
        """getMonths returns a list of tuples of (monthNumber, monthName) where monthNumber
        is 1-12, and monthName is the form January, Febuary, etc. for the the months where
        there is local data for kinst & year combination
        
        Inputs:
            kinst - instrument id (int)
            year - year (int)
            optimize - if True, only start search at beginning of year.  But may miss long experiments,
                so if optimization if False, starts at beginning
        """
        tempDict = {} # dict with key = month number, value = month name
        sDT = datetime.datetime(year,1,1)
        eDT = datetime.datetime(year,12,31,23,59,59)
        madroot = self._madDB.getMadroot()
        if self._madExpObjDate is None:
            self._madExpObjDate = madrigal.metadata.MadrigalExperiment(self._madDB)
        if optimize:
            startIndex = self._madExpObjDate.getStartPosition(sDT)
        else:
            startIndex = 0
        for i in range(startIndex, self._madExpObjDate.getExpCount()):
            thisKinst = self._madExpObjDate.getKinstByPosition(i)
            if kinst != thisKinst:
                continue
            thisSDTList = self._madExpObjDate.getExpStartDateTimeByPosition(i)
            thisSDT = datetime.datetime(*thisSDTList[0:6])
            thisEDTList = self._madExpObjDate.getExpEndDateTimeByPosition(i)
            thisEDT = datetime.datetime(*thisEDTList[0:6])
            if thisEDT < sDT:
                continue
            if thisSDT > eDT:
                continue
            # check for security
            security = self._madExpObjDate.getSecurityByPosition(i)
            if not self.isTrusted(): 
                if security not in (0,2):
                    continue
            else:
                if security not in (0,1,2,3):
                    continue
            if thisSDT.year == year:
                startMonth = thisSDT.month
            else:
                startMonth = 1
            if thisEDT.year == year:
                endMonth = thisEDT.month
            else:
                endMonth = 12
            monthList = list(range(startMonth, endMonth + 1))
            for thisMonth in monthList:
                if thisMonth not in list(tempDict.keys()):
                    tempDict[thisMonth] = calendar.month_name[thisMonth]
                
        monthKeys = list(tempDict.keys())
        monthKeys.sort()
        retList = [(monthKey, tempDict[monthKey]) for monthKey in monthKeys]
        return(retList)
    
    
    def getDays(self, kinst, year, month=None, optimize=True):
        """getDays returns a sorted list of datetime.date objects where
        there is local data for kinst & year & possibly month combination
        
        Inputs:
            kinst - instrument id (int)
            year - year (int)
            month (1-12) if None, include all months
            optimize - if True, only start search at beginning of year.  But may miss long experiments,
                so if optimization if False, starts at beginning
        """
        retList = []
        sDT = datetime.datetime(year,1,1)
        eDT = datetime.datetime(year,12,31,23,59,59)
        if self._madExpObjDate is None:
            self._madExpObjDate = madrigal.metadata.MadrigalExperiment(self._madDB)
        if optimize:
            startIndex = self._madExpObjDate.getStartPosition(sDT)
        else:
            startIndex = 0
        for i in range(startIndex, self._madExpObjDate.getExpCount()):
            thisKinst = self._madExpObjDate.getKinstByPosition(i)
            if kinst != thisKinst:
                continue
            thisSDTList = self._madExpObjDate.getExpStartDateTimeByPosition(i)
            thisSDT = datetime.datetime(*thisSDTList[0:6])
            thisEDTList = self._madExpObjDate.getExpEndDateTimeByPosition(i)
            thisEDT = datetime.datetime(*thisEDTList[0:6])
            if thisEDT < sDT:
                continue
            if thisSDT > eDT:
                continue
            # check for security
            security = self._madExpObjDate.getSecurityByPosition(i)
            if not self.isTrusted():
                if security not in (0,2):
                    continue
            else:
                if security not in (0,1,2,3):
                    continue
            # loop over all days
            delta = datetime.timedelta(days=1)
            loopDT = max(sDT, datetime.datetime(thisSDT.year, thisSDT.month, thisSDT.day))
            while (loopDT <= thisEDT):
                if loopDT > eDT:
                    break
                if not month is None:
                    if month > loopDT.month:
                        loopDT += delta
                        continue
                    elif month < loopDT.month:
                        break
                thisDate = loopDT.date()
                if thisDate not in retList:
                    retList.append(thisDate)
                loopDT += delta
                
                
        retList.sort()
        return(retList)
    
    
    
    def getExperimentList(self, kinstList, startDT, endDT, localOnly):
        """getExperimentList returns a sorted list of tuples of (expId, expUrl, expName, instName, kinst, 
        expStartDT, expEndDT, siteId, siteName)
        
        Inputs:
            kinstList -  a list of instrument id (int) - may include 0
            startDT - start datetime to search
            endDT - end datetime to search
            localOnly - if True, only search locally. If False, search globally
        """
        retList = []
        madroot = self._madDB.getMadroot()
        siteId = self._madDB.getSiteID()
        siteObj = madrigal.metadata.MadrigalSite(self._madDB)
        if localOnly:
            expTabFile = os.path.join(madroot, 'metadata/expTab.txt')
        else:
            expTabFile = os.path.join(madroot, 'metadata/expTabAll.txt')
        madExpObjDate = madrigal.metadata.MadrigalExperiment(self._madDB, expTabFile)
        startIndex = madExpObjDate.getStartPosition(startDT)
        for i in range(startIndex, madExpObjDate.getExpCount()):
            thisKinst = madExpObjDate.getKinstByPosition(i)
            if thisKinst not in kinstList and 0 not in kinstList:
                continue
            thisSDTList = madExpObjDate.getExpStartDateTimeByPosition(i)
            thisSDT = datetime.datetime(*thisSDTList[0:6])
            thisEDTList = madExpObjDate.getExpEndDateTimeByPosition(i)
            thisEDT = datetime.datetime(*thisEDTList[0:6])
            if thisEDT < startDT:
                continue
            if thisSDT > endDT:
                break
            # check for security
            security = madExpObjDate.getSecurityByPosition(i)
            if not self.isTrusted():
                if security not in (0,2):
                    continue
            else:
                if security not in (0,1,2,3):
                    continue
            thisSiteId = madExpObjDate.getExpSiteIdByPosition(i)
            if siteId == thisSiteId:
                isLocal = True
            else:
                isLocal = False
            thisExpId = madExpObjDate.getExpIdByPosition(i)
            thisExpPath = madExpObjDate.getExpPathByPosition(i)
            thisExpName = madExpObjDate.getExpNameByPosition(i)
            if isLocal:
                thisExpUrl = django.urls.reverse('show_experiment') + \
                    '?experiment_list=%i' % (thisExpId)
            elif siteObj.getSiteVersion(thisSiteId) == '2.6':
                thisExpUrl = 'http://' + os.path.join(siteObj.getSiteServer(thisSiteId),
                                          siteObj.getSiteRelativeCGI(thisSiteId),
                                          'madExperiment.cgi?exp=%s' % (thisExpPath))
                thisExpUrl += '&displayLevel=0&expTitle=%s' % (django.utils.http.urlquote(thisExpName))
            else:
                # remote Madrigal 3.0 site
                baseUrl = os.path.basename(django.urls.reverse('show_experiment')[:-1])
                thisExpUrl = baseUrl + '?experiment_list=%s' % (thisExpPath)
                thisSiteUrl = 'http://%s' % (siteObj.getSiteServer(thisSiteId))
                relativeUrl = siteObj.getSiteDocRoot(thisSiteId)
                if relativeUrl not in ('', None):
                    thisSiteUrl = os.path.join(thisSiteUrl, relativeUrl)
                if thisSiteUrl[-1] != '/' and thisExpUrl[0] != '/':
                    thisSiteUrl += '/'
                thisExpUrl = thisSiteUrl + thisExpUrl
                
            thisSiteName = siteObj.getSiteName(thisSiteId)
            instName = self._instObj.getInstrumentName(thisKinst)
            
            retList.append((thisExpId, thisExpUrl, thisExpName, instName, thisKinst, 
                            thisSDT.strftime('%Y-%m-%d %H:%M:%S'), thisEDT.strftime('%Y-%m-%d %H:%M:%S'),
                            thisSiteId, thisSiteName))
                
        return(retList)
    
    
    
    def getExpsOnDate(self, kinst, year, month, day, optimize=True):
        """getExpsOnDate returns a sorted list of tuples of (expId, expDesc, expDir, pi_name, pi_email)
        
        Inputs:
            kinst - instrument id (int)
            year - year (int)
            month - month (int)
            day - day (int)
            optimize - if True, only start search at beginning of day.  But may miss long experiments,
                so if optimization if False, starts at beginning
        """
        retList = []
        sDT = datetime.datetime(year,month,day)
        eDT = datetime.datetime(year,month,day,23,59,59)
        if self._madExpObjDate is None:
            self._madExpObjDate = madrigal.metadata.MadrigalExperiment(self._madDB)
        if optimize:
            startIndex = self._madExpObjDate.getStartPosition(sDT)
        else:
            startIndex = 0
        for i in range(startIndex, self._madExpObjDate.getExpCount()):
            thisKinst = self._madExpObjDate.getKinstByPosition(i)
            if kinst != thisKinst:
                continue
            thisSDTList = self._madExpObjDate.getExpStartDateTimeByPosition(i)
            thisSDT = datetime.datetime(*thisSDTList[0:6])
            thisEDTList = self._madExpObjDate.getExpEndDateTimeByPosition(i)
            thisEDT = datetime.datetime(*thisEDTList[0:6])
            if thisEDT < sDT:
                continue
            if thisSDT > eDT:
                continue
            # check for security
            security = self._madExpObjDate.getSecurityByPosition(i)
            if not self.isTrusted():
                if security not in (0,2):
                    continue
            else:
                if security not in (0,1,2,3):
                    continue
            thisExpId = self._madExpObjDate.getExpIdByPosition(i)
            thisExpName = self._madExpObjDate.getExpNameByPosition(i)
            thisExpDesc = '%s: %s-%s' % (thisExpName, thisSDT.strftime('%Y-%m-%d %H:%M:%S'),
                                         thisEDT.strftime('%Y-%m-%d %H:%M:%S'))
            thisExpDir = self._madExpObjDate.getExpDirByPosition(i)
            thisExpPI = self._madExpObjDate.getPIByPosition(i)
            thisExpPIEmail = self._madExpObjDate.getPIEmailByPosition(i)
            if thisExpPI in (None, ''):
                thisExpPI = self._instObj.getContactName(kinst)
                thisExpPIEmail = self._instObj.getContactEmail(kinst)
            retList.append((thisExpId, thisExpDesc, thisExpDir))
                
        return(retList)
    
    
    
    def getFileFromExpDir(self, expDir, kinst, includeNonDefault=False):
        """getFileFromExpDir returns a list of tuples of (basename, fileDesc)
        
        Inputs:
            expDir - full path to exp directory
            kinst - instrument id (used to look up kindat descriptions)
            includeNonDefault - if True, include variant and history files.  If False
                (the default), do not
        """
        retList = []
        realTimeList = [] # in case no default files
        if not os.access(os.path.join(expDir, 'fileTab.txt'), os.R_OK):
            # no files in this experiment
            return(retList)
        madFileObj = madrigal.metadata.MadrigalMetaFile(self._madDB, os.path.join(expDir, 'fileTab.txt'))
        for i in range(madFileObj.getFileCount()):
            if madFileObj.getAccessByPosition(i) == 1 and not self.isTrusted():
                continue
            category = madFileObj.getCategoryByPosition(i)
            if category in (2,3) and not includeNonDefault:
                continue
            basename = madFileObj.getFilenameByPosition(i)
            kindat = madFileObj.getKindatByPosition(i)
            kindatDesc = self._madKindatObj.getKindatDescription(kindat, kinst)
            status = madFileObj.getStatusByPosition(i)
            fileDesc = '%s: %s - %s' % (basename, kindatDesc, status)
            if category != 4:
                retList.append((basename, fileDesc))
            else:
                realTimeList.append((basename, fileDesc))
            
        if len(retList) > 0:
            return(retList)
        else:
            return(realTimeList)
        
    
    def getExpInfoFromExpID(self, expID):
        """getExpInfoFromExpID returns a tuple of (pi_name, pi_email, expUrl, kinst, expDesc, kinstDesc) for given expID
        
        expUrl is url from getRealExpUrlByExpId
        
        Inputs:
            expID - experimentID (int)
        """
        expID = int(expID)
        if self._madExpObjExpID is None:
            self._madExpObjExpID = madrigal.metadata.MadrigalExperiment(self._madDB)
        kinst = self._madExpObjExpID.getKinstByExpId(expID)
        kinstDesc = self._instObj.getInstrumentName(kinst)
        expPI = self._madExpObjExpID.getPIByExpId(expID)
        expPIEmail = self._madExpObjExpID.getPIEmailByExpId(expID)
        expUrl = self._madExpObjExpID.getRealExpUrlByExpId(expID)
        if expPI in (None, ''):
            expPI = self._instObj.getContactName(kinst)
            expPIEmail = self._instObj.getContactEmail(kinst)
        thisSDTList = self._madExpObjExpID.getExpStartDateTimeByExpId(expID)
        thisSDT = datetime.datetime(*thisSDTList[0:6])
        thisEDTList = self._madExpObjExpID.getExpEndDateTimeByExpId(expID)
        thisEDT = datetime.datetime(*thisEDTList[0:6])
        thisExpName = self._madExpObjExpID.getExpNameByExpId(expID)
        thisExpDesc = '%s: %s-%s' % (thisExpName, thisSDT.strftime('%Y-%m-%d %H:%M:%S'),
                                     thisEDT.strftime('%Y-%m-%d %H:%M:%S'))
        
        return((expPI, expPIEmail, expUrl, kinst, thisExpDesc, kinstDesc))
    
    
    def getExpIDFromExpPath(self, expPath, matchAnyExpNum=False):
        """getExpIDFromExpPath returns the expId for given expPath (starts with 'experiments')
        
        If matchAnyExpNum is False, it will only match the right experiments* directory (default).
        It True, matches via re to experiments[0-9]*/<remaining exp path>
        
        Returns None if not found
        
        Inputs:
            expPath - experiment path (starts with 'experiments')
        """
        madExpObj = madrigal.metadata.MadrigalExperiment(self._madDB)
        if matchAnyExpNum:
            expPathRE = 'experiments[0-9]*/' + expPath[expPath.find('/')+1:]
        for i in range(madExpObj.getExpCount()):
            if not matchAnyExpNum:
                if madExpObj.getExpPathByPosition(i) == expPath:
                    return(madExpObj.getExpIdByPosition(i))
            else:
                if len(re.findall(expPathRE, madExpObj.getExpPathByPosition(i))) > 0:
                    return(madExpObj.getExpIdByPosition(i))
        
        return(None)
    
    
    def getInfoFromFile(self, filePath):
        """getInfoFromFile returns a tuple of (expName, kindatDesc) for a given input file
        """
        expDir = os.path.dirname(filePath)
        basename = os.path.basename(filePath)
        madExpObj = madrigal.metadata.MadrigalExperiment(self._madDB, os.path.join(expDir, 'expTab.txt'))
        expName = madExpObj.getExpNameByPosition(0)
        kinst = madExpObj.getKinstByPosition(0)
        madFileObj = madrigal.metadata.MadrigalMetaFile(self._madDB, os.path.join(expDir, 'fileTab.txt'))
        kindat = madFileObj.getKindatByFilename(basename)
        kindatDesc = self._madKindatObj.getKindatDescription(kindat, kinst)
        return((expName, kindatDesc))
        
        
        
        
    def getFileFromExpID(self, expID, includeNonDefault=False):
        """getFileFromExpDir returns a list of tuples of (basename, fileDesc)
        
        Inputs:
            expID - experimentID (int)
            includeNonDefault - if True, include variant and history files.  If False
                (the default), do not
        """
        retList = []
        realTimeList = [] # in case no default files
        if self._madExpObjExpID is None:
            self._madExpObjExpID = madrigal.metadata.MadrigalExperiment(self._madDB)
        expDir = self._madExpObjExpID.getExpDirByExpId(expID)
        kinst = self._madExpObjExpID.getKinstByExpId(expID)
        
        if not os.access(os.path.join(expDir, 'fileTab.txt'), os.R_OK):
            # no files in this experiment
            return(retList)
        
        madFileObj = madrigal.metadata.MadrigalMetaFile(self._madDB, os.path.join(expDir, 'fileTab.txt'))
        for i in range(madFileObj.getFileCount()):
            if madFileObj.getAccessByPosition(i) == 1 and not self.isTrusted():
                continue
            category = madFileObj.getCategoryByPosition(i)
            if category in (2,3) and not includeNonDefault:
                continue
            if category == 2:
                categoryStr = '<variant file> '
            elif category == 3:
                categoryStr = '<history file> '
            else:
                categoryStr = ''
            basename = madFileObj.getFilenameByPosition(i)
            kindat = madFileObj.getKindatByPosition(i)
            kindatDesc = self._madKindatObj.getKindatDescription(kindat, kinst)
            status = madFileObj.getStatusByPosition(i)
            fileDesc = '%s: %s%s - %s' % (basename, categoryStr, kindatDesc, status)
            if category != 4:
                retList.append((basename, fileDesc))
            else:
                realTimeList.append((basename, fileDesc))
            
        if len(retList) > 0:
            return(retList)
        else:
            return(realTimeList)
        
        
    def getSiteInfo(self):
        """getSiteInfo returns a tuple of two items:
            1. local site name
            2. list of tuples of (siteName, url) of non-local sites
        """
        siteID = self._madDB.getSiteID()
        siteObj = madrigal.metadata.MadrigalSite(self._madDB)
        siteName = siteObj.getSiteName(siteID)
        retList = []
        siteList = siteObj.getSiteList()
        for thisSiteID, thisSiteName in siteList:
            if thisSiteID == siteID:
                continue
            thisSiteServer = siteObj.getSiteServer(thisSiteID)
            thisSiteDocRoot = siteObj.getSiteDocRoot(thisSiteID)
            thisSiteUrl = urllib.parse.urlunparse(('http', thisSiteServer, thisSiteDocRoot, '','',''))
            retList.append((thisSiteName, thisSiteUrl))
        return((siteName, retList))
    
    
    def downloadFileAsIs(self, expId, basename, user_fullname, user_email, user_affiliation):
        """downloadFileAsIs returns a path to a Madrigal file to download as is (that is, with parms in file, and no filters)
        
        Inputs:
            expId - experiment id of experiment
            basename - basename of file.  May have .txt or .nc extension, in which case Hdf5 file is converted
            user_fullname, user_email, user_affiliation - user identification strings
        """
        self.cleanStage()
        hdf5Extensions = ('.hdf5', '.h5', '.hdf')
        fileName, fileExtension = os.path.splitext(basename)
        if self._madExpObjExpID is None:
            self._madExpObjExpID = madrigal.metadata.MadrigalExperiment(self._madDB)
        expDir = self._madExpObjExpID.getExpDirByExpId(int(expId))
        if expDir is None:
            raise ValueError('No expDir found for exp_id %i' % (int(expId)))
        if fileExtension in hdf5Extensions:
            baseHdf5 = basename
        else:
            # we need to search for the hdf5 basename
            madFileObj = madrigal.metadata.MadrigalMetaFile(self._madDB, os.path.join(expDir, 'fileTab.txt'))
            baseHdf5 = None
            for i in range(madFileObj.getFileCount()):
                thisFileName, thisFileExt = os.path.splitext(madFileObj.getFilenameByPosition(i))
                if thisFileName == fileName and thisFileExt in hdf5Extensions:
                    baseHdf5 = madFileObj.getFilenameByPosition(i)
                    break
        if baseHdf5 is None:
            raise ValueError('No valid file for %s found in %s' % (basename, expDir))
        if basename == baseHdf5:
            fullFilename = os.path.join(expDir, basename)
            fullHdf5Filename = fullFilename
            tmpDir = None
        else:
            fullHdf5Filename = os.path.join(expDir, baseHdf5)
            # create tmp dir if needed
            tmpDir = os.path.join(self._madDB.getMadroot(), 'experiments/stage')
            try:
                os.mkdir(tmpDir)
            except:
                pass
            fullFilename = os.path.join(tmpDir, basename)
            if os.access(fullFilename, os.R_OK):
                try:
                    os.remove(fullFilename)
                except:
                    pass
            if fileExtension == '.txt':
                cachedFile = os.path.join(expDir, 'overview', baseHdf5 + '.txt.gz')
                if os.access(cachedFile, os.R_OK):
                    fullFilename += '.gz'
                    shutil.copy(cachedFile, fullFilename)
                else:
                    madrigal.cedar.convertToText(fullHdf5Filename, fullFilename)
            elif fileExtension == '.nc':
                cachedFile = os.path.join(expDir, 'overview', baseHdf5 + '.nc')
                if os.access(cachedFile, os.R_OK):
                    shutil.copy(cachedFile, fullFilename)
                else:
                    try:
                        madrigal.cedar.convertToNetCDF4(fullHdf5Filename, fullFilename)
                    except IOError:
                        cedarObj = madrigal.cedar.MadrigalCedarFile(fullHdf5Filename)
                        cedarObj.write('netCDF4', fullFilename)
                
        # log access
        self.logDataAccess(fullHdf5Filename, user_fullname, user_email, user_affiliation)
        
        return(fullFilename)
    
    
    
    def downloadFullFileAsIs(self, fullHdf5Filename, format, user_fullname, user_email, user_affiliation):
        """downloadFullFileAsIs is similar to downloadFileAsIs with fullFilename input instead of expId .
        
        Returns a path to a Madrigal file to download as is (that is, with parms in file, and no filters)
        
        Inputs:
            fullHdf5Filename - full path to Madrigal Hdf5 file
            format - 'hdf5', 'netCDF4', or 'ascii'
            user_fullname, user_email, user_affiliation - user identification strings
        """
        self.cleanStage()
        if format not in ('hdf5', 'netCDF4', 'ascii'):
            raise ValueError('Illegal format %s' % (str(format)))
        if not os.access(fullHdf5Filename, os.R_OK):
            raise IOError('Unable to find Hdf5 file %s' % (str(fullHdf5Filename)))
        if format == 'hdf5':
            fullFilename = fullHdf5Filename
            tmpDir = None
        else:
            # dynamically create file
            if format == 'netCDF4':
                thisExt = '.nc'
            elif format == 'ascii':
                thisExt = '.txt'
            # create tmp dir if needed
            tmpDir = os.path.join(self._madDB.getMadroot(), 'experiments/stage')
            try:
                os.mkdir(tmpDir)
            except:
                pass
            base, file_extension = os.path.splitext(fullHdf5Filename)
            basename = os.path.basename(base + thisExt)
            fullFilename = os.path.join(tmpDir, basename)
            if os.access(fullFilename, os.R_OK):
                try:
                    os.remove(fullFilename)
                except:
                    pass

            if format == 'ascii':
                cachedFile = os.path.join(os.path.dirname(fullHdf5Filename), 'overview', 
                                          os.path.basename(fullHdf5Filename) + '.txt.gz')
                if os.access(cachedFile, os.R_OK):
                    fullFilename += '.gz'
                    shutil.copy(cachedFile, fullFilename)
                else:
                    madrigal.cedar.convertToText(fullHdf5Filename, fullFilename)
            elif format == 'netCDF4':
                cachedFile = os.path.join(os.path.dirname(fullHdf5Filename), 'overview', 
                                          os.path.basename(fullHdf5Filename) + '.nc')
                if os.access(cachedFile, os.R_OK):
                    shutil.copy(cachedFile, fullFilename)
                else:
                    try:
                        madrigal.cedar.convertToNetCDF4(fullHdf5Filename, fullFilename)
                    except IOError:
                        cedarObj = madrigal.cedar.MadrigalCedarFile(fullHdf5Filename)
                        cedarObj.write('netCDF4', fullFilename)
                
        # log access
        self.logDataAccess(fullHdf5Filename, user_fullname, user_email, user_affiliation)
        
        return(fullFilename)
    
    
    def downloadMultipleFiles(self, fileList, format, user_fullname, user_email, user_affiliation):
        """downloadMultipleFiles downloads multiple files in tarred format
        
        Returns a path to a Madrigal tarred file to download in given format as is (that is, with parms in file, and no filters)
        
        Inputs:
            fileList - list of full paths to Madrigal Hdf5 files
            format - 'hdf5', 'netCDF4', or 'ascii'
            user_fullname, user_email, user_affiliation - user identification strings
        """
        self.cleanStage()
        if format not in ('hdf5', 'netCDF4', 'ascii'):
            raise ValueError('Illegal format %s' % (str(format)))
        # create tmp dir if needed
        tmpDir = os.path.join(self._madDB.getMadroot(), 'experiments/stage')
        try:
            os.mkdir(tmpDir)
        except:
            pass
        # be sure no duplicate file names
        basenameList = []
        if format == 'hdf5':
            finalFileList = []
            for thisFile in fileList:
                basename = os.path.basename(thisFile)
                dirname = os.path.dirname(thisFile)
                if basename in basenameList:
                    basename = self.modifyBasename(basename)
                    fullFilename = os.path.join(tmpDir, basename)
                    shutil.copy(thisFile, fullFilename)
                else:
                    fullFilename = os.path.join(dirname, basename)
                basenameList.append(basename)
                finalFileList.append(fullFilename)
                
        else:
            # dynamically create files
            if format == 'netCDF4':
                thisExt = '.nc'
            elif format == 'ascii':
                thisExt = '.txt'
            finalFileList = []
            for thisFile in fileList:
                if not os.access(thisFile, os.R_OK):
                    raise IOError('Unable to find Hdf5 file %s' % (str(thisFile)))
                base, file_extension = os.path.splitext(thisFile)
                basename = os.path.basename(base + thisExt)
                if basename in basenameList:
                    basename = self.modifyBasename(basename)
                basenameList.append(basename)
                fullFilename = os.path.join(tmpDir, basename)
                
                if format == 'ascii':
                    cachedFile = os.path.join(os.path.dirname(thisFile), 'overview', 
                                              os.path.basename(thisFile) + '.txt.gz')
                    if os.access(cachedFile, os.R_OK):
                        fullFilename += '.gz'
                        if not os.access(fullFilename, os.R_OK):
                            shutil.copy(cachedFile, fullFilename)
                    else:
                        madrigal.cedar.convertToText(thisFile, fullFilename)
                elif format == 'netCDF4':
                    cachedFile = os.path.join(os.path.dirname(thisFile), 'overview', 
                                              os.path.basename(thisFile) + '.nc')
                    if os.access(cachedFile, os.R_OK):
                        if not os.access(fullFilename, os.R_OK):
                            shutil.copy(cachedFile, fullFilename)
                    else:
                        try:
                            madrigal.cedar.convertToNetCDF4(thisFile, fullFilename)
                        except IOError:
                            cedarObj = madrigal.cedar.MadrigalCedarFile(thisFile)
                            cedarObj.write('netCDF4', fullFilename)
                finalFileList.append(fullFilename)
                
        # create tar file
        now = datetime.datetime.now()
        tar_filename = os.path.join(tmpDir, 'madrigalFiles_%s.tar' % (now.strftime('%Y%m%dT%H%M%S')))
        tar = tarfile.open(tar_filename, "w")
        for thisFile in finalFileList:
            # log access
            self.logDataAccess(thisFile, user_fullname, user_email, user_affiliation)
            tar.add(thisFile)
            # let clean stage do this - safer
        return(tar_filename)
        
    
    
    
    def printFileAsIs(self, fullFilename, user_fullname, user_email, user_affiliation, html=True):
        """printFileAsIs returns the full path to a temp file representing file as plain text or html to print as is (that is, with parms rom file, and no filters)
        
        Inputs:
            fullFilename - full path to Madrigal Hdf5 file to convert to string
            user_fullname, user_email, user_affiliation - user identification strings
            html - if True (the default) return as Html with popup parm names.  If False, pure text
        """
        self.cleanStage()
        
        # create tmp dir if needed
        tmpDir = os.path.join(self._madDB.getMadroot(), 'experiments/stage')
        try:
            os.mkdir(tmpDir)
        except:
            pass
        
        fileName, fileExtension = os.path.splitext(fullFilename)
        fullTmpFilename = os.path.join(tmpDir, os.path.basename(fileName + '.txt'))

        if os.access(fullTmpFilename, os.R_OK):
            try:
                os.remove(fullTmpFilename)
            except:
                pass
        if html:
            summary = 'html'
        else:
            summary = 'plain'
        madrigal.cedar.convertToText(fullFilename, fullTmpFilename, summary=summary)
                
        # log access
        self.logDataAccess(fullFilename, user_fullname, user_email, user_affiliation)
        
        return(fullTmpFilename)
    
    
    def listRecords(self, fullFilename):
        """listRecords returns the list records html for fullFilename
        """
        # check if record plots exist
        basename = os.path.basename(fullFilename)
        thisDir = os.path.dirname(fullFilename)
        pngFiles = glob.glob(os.path.join(thisDir, 'plots', basename, 'records/*.png'))
        if len(pngFiles) > 0:
            url = '<a href="javascript:plotRecno(%i)">View record plot</a>'
        else:
            url = None
        
        output = os.path.join(tempfile.gettempdir(), 'tmp_%i.txt' % (random.randint(0,999999)))
        
        madrigal.cedar.listRecords(fullFilename, output, url)
        
        f = open(output)
        text = f.read()
        f.close()
        os.remove(output)
        return(text.strip())
        
    
    
    def downloadIsprintFileFromIsprintForm(self, isprintForm, user_fullname, user_email, user_affiliation):
        """downloadIsprintFileFromIsprintForm returns a full path to the temp file is experiments/stage created by isprint to download.
        
        Inputs:
            isprintForm - the django form that encapsulates all information from get_advanced web page.  
            user_fullname, user_email, user_affiliation - user identification strings
        """
        # defaults arguments
        showHeaders=False
        missing=None
        assumed=None
        knownbad=None
        
        orgFilename = isprintForm['fullFilename']
        requestedParms = isprintForm['parameters']
        # make unique
        uniqueRequestedParms = []
        for s in requestedParms:
            if type(s) in (bytes, numpy.bytes_):
                s = s.decode("ascii")
            asciiParm = s.lower().strip()
            if asciiParm not in uniqueRequestedParms:
                uniqueRequestedParms.append(asciiParm)
        start_date = isprintForm['start_date']
        end_date = isprintForm['end_date']
        
        format = isprintForm['formats']
        # create name of temp file
        basename_noext, ext = os.path.splitext(os.path.basename(orgFilename))
        randint = random.randint(0,999999)
        if format in ('ascii', 'netCDF4'):
            # need new basename
            if format == 'ascii':
                basename = basename_noext + '_%06i.txt' % (randint)
            else:
                basename = basename_noext + '_%06i.nc' % (randint)
        else:
            basename = basename_noext + '_%06i.hdf5' % (randint)
        tmpFile = os.path.join(self._madDB.getMadroot(), 'experiments/stage', basename)
        
        if format == 'ascii':
            # reset defaults
            showHeaders = isprintForm['showHeaders']
            missing = isprintForm['missing']
            assumed = isprintForm['missing']
            knownbad = isprintForm['missing']
            
        # next task - create a list of filters, but only if actually modified
        madFilters = []
        
        madFileObj = madrigal.data.MadrigalFile(orgFilename, self._madDB) # used to determine default values
        
        # check if we need a time filer
        earliestTime = madFileObj.getEarliestTime()
        latestTime = madFileObj.getLatestTime()
        earliestDT = datetime.datetime(*earliestTime)
        latestDT = datetime.datetime(*latestTime)
        earliest_unix = calendar.timegm(earliestDT.timetuple())
        latest_unix = calendar.timegm(latestDT.timetuple())
        start_unix = calendar.timegm(start_date.timetuple())
        end_unix = calendar.timegm(end_date.timetuple())
        
        if earliest_unix < start_unix or latest_unix > end_unix:
            # we need a time filter
            madFilters.append(madrigal.derivation.MadrigalFilter('ut1_unix', [(start_unix, end_unix)]))
            
        # altitude filter
        if 'min_alt' in isprintForm:
            file_min_alt = madFileObj.getMinValidAltitude()
            file_max_alt = madFileObj.getMaxValidAltitude()
            try:
                min_alt = float(isprintForm['min_alt'])
            except ValueError:
                min_alt = float('nan')
            try:
                max_alt = float(isprintForm['max_alt'])
            except ValueError:
                max_alt = float('nan')
            is_needed = False
            if not math.isnan(min_alt):
                if min_alt > file_min_alt + 1.0E-6:
                    is_needed = True
            if not math.isnan(max_alt):
                if max_alt < file_max_alt - 1.0E-6:
                    is_needed = True
            if is_needed:
                madFilters.append(madrigal.derivation.MadrigalFilter('gdalt', [(min_alt, max_alt)]))
                
        # azimuth filter
        if 'min_az' in isprintForm:
            try:
                min_az = float(isprintForm['min_az'])
            except ValueError:
                min_az = float('nan')
            try:
                max_az = float(isprintForm['max_az'])
            except ValueError:
                max_az = float('nan')
            try:
                min_az2 = float(isprintForm['min_az2'])
            except ValueError:
                min_az2 = float('nan')
            try:
                max_az2 = float(isprintForm['max_az2'])
            except ValueError:
                max_az2 = float('nan')
            is_needed = False
            if not math.isnan(min_az):
                if min_az > -180.0:
                    is_needed = True
            if not math.isnan(max_az):
                if max_az < 180.0:
                    is_needed = True
            if is_needed:
                madFilters.append(madrigal.derivation.MadrigalFilter('azm', [(min_az, max_az), (min_az2, max_az2)]))
                
        # elevation filter
        if 'min_el' in isprintForm:
            try:
                min_el = float(isprintForm['min_el'])
            except ValueError:
                min_el = float('nan')
            try:
                max_el = float(isprintForm['max_el'])
            except ValueError:
                max_el = float('nan')
            try:
                min_el2 = float(isprintForm['min_el2'])
            except ValueError:
                min_el2 = float('nan')
            try:
                max_el2 = float(isprintForm['max_el2'])
            except ValueError:
                max_el2 = float('nan')
            is_needed = False
            if not math.isnan(min_el):
                if min_el > 0.0:
                    is_needed = True
            if not math.isnan(max_el):
                if max_el < 90.0:
                    is_needed = True
            if is_needed:
                madFilters.append(madrigal.derivation.MadrigalFilter('azm', [(min_el, max_el), (min_el2, max_el2)]))  
            
        # pulse length filter
        if 'min_pl' in isprintForm:
            file_min_pl = madFileObj.getMinPulseLength()
            file_max_pl = madFileObj.getMaxPulseLength()
            try:
                min_pl = float(isprintForm['min_pl'])
            except ValueError:
                min_pl = float('nan')
            try:
                max_pl = float(isprintForm['max_pl'])
            except ValueError:
                max_pl = float('nan')
            is_needed = False
            if not math.isnan(min_pl):
                if min_pl > file_min_pl + 1.0E-9:
                    is_needed = True
            if not math.isnan(max_pl):
                if max_pl < file_max_pl - 1.0E-9:
                    is_needed = True
            if is_needed:
                madFilters.append(madrigal.derivation.MadrigalFilter('pl', [(min_pl, max_pl)]))
        
        # free parameters
        for i in range(1, 4):
            parm_name = isprintForm['parm_%i' % (i)]
            parm_lower = isprintForm['parm_%i_lower' % (i)]
            parm_upper = isprintForm['parm_%i_upper' % (i)]
            if parm_name == 'None':
                continue
            if len(parm_lower) == 0 and len(parm_upper) == 0:
                continue
            # filter needed
            try:
                min_value = float(parm_lower)
            except ValueError:
                min_value = float('nan')
            try:
                max_value = float(parm_upper)
            except ValueError:
                max_value = float('nan')
            madFilters.append(madrigal.derivation.MadrigalFilter(parm_name, [(min_value, max_value)]))
            
        # create new temp file
        madrigal.isprint.Isprint(orgFilename, tmpFile, uniqueRequestedParms, madFilters,
                                 showHeaders=showHeaders, missing=missing, assumed=assumed, knownbad=knownbad)
        
        # log access
        self.logDataAccess(orgFilename, user_fullname, user_email, user_affiliation)
        
        return(tmpFile)
    
    
    def runMadrigalCalculatorFromForm(self, madCalculatorForm):
        """runMadrigalCalculatorFromForm returns the text output of madCalculator from the MadCalulatorForm
        
        Inputs:
            madCalculatorForm - the django form that encapsulates all information from madrigal_calculator web page.  
        """
        requestedParms = madCalculatorForm['parameters']
        requestedParms = ['gdlat', 'glon', 'gdalt'] + [str(parm) for parm in requestedParms]
        thisDT = madCalculatorForm['datetime']
        
        min_latitude = madCalculatorForm['min_latitude']
        max_latitude = madCalculatorForm['max_latitude']
        delta_latitude = madCalculatorForm['delta_latitude']
        
        min_longitude = madCalculatorForm['min_longitude']
        max_longitude = madCalculatorForm['max_longitude']
        delta_longitude = madCalculatorForm['delta_longitude']
        
        min_altitude = madCalculatorForm['min_altitude']
        max_altitude = madCalculatorForm['max_altitude']
        delta_altitude = madCalculatorForm['delta_altitude']
        
        latList = numpy.arange(min_latitude, max_latitude+0.001*delta_latitude, delta_latitude).tolist()
        lonList = numpy.arange(min_longitude, max_longitude+0.001*delta_longitude, delta_longitude).tolist()
        altList = numpy.arange(min_altitude, max_altitude+0.001*delta_altitude, delta_altitude).tolist()
        
        if 0 in (len(latList), len(lonList), len(altList)):
            raise ValueError('Got 0 length spatial range')
        
        output = os.path.join(tempfile.gettempdir(), 'tmp_%i.txt' % (random.randint(0,999999)))
        
        madrigal.isprint.MadCalculatorGrid(output, requestedParms, [thisDT], latList, lonList, altList)
        
        f = open(output)
        text = f.read()
        f.close()
        os.remove(output)
        return(text.strip())
    
    
    def runLookerFromForm(self, form):
        """runLookerFromForm returns the text output of looker from one of the looker forms
        
        Inputs:
            form - the django form that encapsulates all information from looker web page.  
        """
        looker_cmd = os.path.join(self._madDB.getMadroot(), 'bin/looker1')
        looker_options = int(form['looker_options'])
        if looker_options in (1,2):
            try:
                kinst = int(form['instruments'])
                if kinst == 0:
                    raise ValueError('')
                slatgd = self._instObj.getLatitude(kinst)
                slon = self._instObj.getLongitude(kinst)
                if slon > 180.0:
                    slon -= 360.0
                saltgd = self._instObj.getAltitude(kinst)
            except:
                slatgd = float(form['inst_lat'])
                slon = float(form['inst_lon'])
                saltgd = float(form['inst_alt'])
            try:
                year = float(form['year'])
            except:
                year = 2000.0
            argStr = ' %i ' + '%f ' * 13
            argStr = argStr % (looker_options, year, slatgd, slon, saltgd,
                               float(form['start_lat']), float(form['stop_lat']), float(form['step_lat']),
                               float(form['start_lon']), float(form['stop_lon']), float(form['step_lon']),
                               float(form['start_alt']), float(form['stop_alt']), float(form['step_alt']))
            looker_cmd += argStr
            try:
                text = subprocess.check_output(looker_cmd.split())
            except:
                raise IOError('Unable to run cmd <%s>' % (looker_cmd))
            if type(text) == bytes:
                text = text.decode('utf-8')
            return(text)
        
        elif looker_options in (3,):
            try:
                year = float(form['year'])
            except:
                year = 2000.0
            argStr = ' %i ' + '%f ' * 13
            argStr = argStr % (looker_options, year, 0.0, 0.0, 0.0,
                               float(form['start_lat']), float(form['stop_lat']), float(form['step_lat']),
                               float(form['start_lon']), float(form['stop_lon']), float(form['step_lon']),
                               float(form['start_alt']), float(form['stop_alt']), float(form['step_alt']))
            looker_cmd += argStr
            text = subprocess.check_output(looker_cmd.split())
            if type(text) == bytes:
                text = text.decode('utf-8')
            return(text)
        elif looker_options in (4,):
            try:
                kinst = int(form['instruments'])
                if kinst == 0:
                    raise ValueError('')
                slatgd = self._instObj.getLatitude(kinst)
                slon = self._instObj.getLongitude(kinst)
                if slon > 180.0:
                    slon -= 360.0
                saltgd = self._instObj.getAltitude(kinst)
            except:
                slatgd = float(form['inst_lat'])
                slon = float(form['inst_lon'])
                saltgd = float(form['inst_alt'])
            try:
                year = float(form['year'])
            except:
                year = 2000.0
            argStr = ' %i ' + '%f ' * 13
            argStr = argStr % (looker_options, year, slatgd, slon, saltgd,
                               float(form['start_az']), float(form['stop_az']), float(form['step_az']),
                               float(form['start_el']), float(form['stop_el']), float(form['step_el']),
                               float(form['start_range']), float(form['stop_range']), float(form['step_range']))
            looker_cmd += argStr
            text = subprocess.check_output(looker_cmd.split())
            if type(text) == bytes:
                text = text.decode('utf-8')
            return(text)
        elif looker_options in (5,6,7):
            try:
                kinst = int(form['instruments'])
                if kinst == 0:
                    raise ValueError('')
                slatgd = self._instObj.getLatitude(kinst)
                slon = self._instObj.getLongitude(kinst)
                if slon > 180.0:
                    slon -= 360.0
                saltgd = self._instObj.getAltitude(kinst)
            except:
                slatgd = float(form['inst_lat'])
                slon = float(form['inst_lon'])
                saltgd = float(form['inst_alt'])
            try:
                year = float(form['year'])
            except:
                year = 2000.0
            argStr = ' %i ' + '%f ' * 13
            if looker_options == 5:
                p1 = float(form['fl_az'])
                p2 = float(form['fl_el'])
                p3 = float(form['fl_range'])
            elif looker_options == 6:
                p1 = float(form['fl_lat'])
                p2 = float(form['fl_lon'])
                p3 = float(form['fl_alt'])
            elif looker_options == 7:
                p1 = float(form['fl_apex_lat'])
                p2 = float(form['fl_apex_lon'])
                p3 = 0.0
            argStr = argStr % (looker_options, year, slatgd, slon, saltgd,
                               p1, p2, p3,
                               float(form['start_alt']), float(form['stop_alt']), float(form['step_alt']),
                               0.0, 0.0, 0.0)
            looker_cmd += argStr
            text = subprocess.check_output(looker_cmd.split())
            if type(text) == bytes:
                text = text.decode('utf-8')
            return(text)
        elif looker_options in (8,):
            latList = numpy.arange(float(form['start_lat']), float(form['stop_lat']), float(form['step_lat']))
            latList = latList.tolist()
            # check for null list
            if len(latList) == 0 and abs(float(form['start_lat']) - float(form['stop_lat'])) < 1.0E-6:
                latList = [float(form['start_lat'])]
            lonList = numpy.arange(float(form['start_lon']), float(form['stop_lon']), float(form['step_lon']))
            lonList = lonList.tolist()
            # check for null list
            if len(lonList) == 0 and abs(float(form['start_lon']) - float(form['stop_lon'])) < 1.0E-6:
                lonList = [float(form['start_lon'])]
            altList = numpy.arange(float(form['start_alt']), float(form['stop_alt']), float(form['step_alt']))
            altList = altList.tolist()
            # check for null list
            if len(altList) == 0 and abs(float(form['start_alt']) - float(form['stop_alt'])) < 1.0E-6:
                altList = [float(form['start_alt'])]
            requestedParms = ['gdlat', 'glon', 'gdalt'] + [str(parm.lower()) for parm in form['pList']]
            dtList = [form['datetime']]
            output = os.path.join(tempfile.gettempdir(), 'tmp_%i.txt' % (random.randint(0,999999)))

            madrigal.isprint.MadCalculatorGrid(output, requestedParms, dtList, latList, lonList, altList)
            f = open(output)
            text = f.read()
            f.close()
            os.remove(output)
            if type(text) == bytes:
                text = text.decode('utf-8')
            return(text.strip())
            
        else:
            raise ValueError('Unknown looker_options %s' % (str(looker_options)))
        
            
        
        
    def cleanStage(self):
        """cleanStage removes all temp files more than 2 hours old from experiments/stage
        """
        stageDir = os.path.join(self._madDB.getMadroot(), 'experiments/stage')
        filesToTest = glob.glob(os.path.join(stageDir, '*'))
        now = datetime.datetime.now()
        cutoff = datetime.timedelta(hours=2)
        for fileToTest in filesToTest:
            try:
                mDT = datetime.datetime.fromtimestamp(os.path.getmtime(fileToTest))
            except:
                continue
            if now - mDT > cutoff:
                try:
                    os.remove(fileToTest)
                except:
                    pass # ignore problems
                
                
    def modifyBasename(self, basename):
        """modifyBasename adds _<num> to make sure basename unique
        """
        base, file_extension = os.path.splitext(basename)
        index = base.rfind('_')
        if index != -1:
            try:
                length = len(base[index+1:])
                version = int(base[index+1:])
                # in case of overflow
                length = max(length, len(str(version + 1)))
                format = '%%0%ii' % (length)
                return('%s_%s%s' % (base[:index], format % (version + 1), file_extension))
            except:
                pass
        return('%s_%i%s' % (base, 1, file_extension))
            
            
        
            
            
    def _getDaynoFilter(self, seasonalStartDate, seasonalEndDate):
        """_getDaynoFilter returns a filter str in the form dayno,<lower>,<upper>
        
        Inputs:
            seasonalStartDate - a string in form 'MM/DD'.  Assumes non-leap year.
                Empty string means no filtering by seasonal start date.
            seasonalStartDate - a string in form 'MM/DD'.  Assumes non-leap year.
                Empty string means no filtering by seasonal end date.
        """
        startDayno = ''
        endDayno = ''
        if len(seasonalStartDate):
            startItems = seasonalStartDate.split('/')
            startDT = datetime.datetime(1958, int(startItems[0]),  int(startItems[1]))
            startDayno = int(startDT.strftime('%j'))
        if len(seasonalEndDate):
            endItems = seasonalEndDate.split('/')
            endDT = datetime.datetime(1958, int(endItems[0]),  int(endItems[1]))
            endDayno = int(endDT.strftime('%j'))
        return('dayno,%i,%i' % (startDayno, endDayno))


    def _getLock(self, filename):
        """_getLock is a private helper function that provides exclusive access to filename via a locking file.

        Inputs: filename = the file that exclusive access is required to.
        
        Returns: None

        Affects: Writes file filename + .LCK as a lock mechanism

        Exceptions: MadrigalError thrown if unable to write lock file

        Notes: Will sleep for 1 second at a time, for a maximum of _MaxSleep seconds (presently 10)
        if the file is not modified. After each second, it will check for the lock file to be removed
        or modified. If it was modified, it resets the count to 0 sec and starts counting again. After
        _MaxSleep counts it then assumes lock file is orphaned and returns.  Orphaned file will be
        removed when dropLock is called.
        """
        gotLock = 0
        numTries = 0
        modificationTime = 0
        
        while (not gotLock):

            try:
                file = os.open(filename + '.LCK', os.O_RDWR | os.O_CREAT | os.O_EXCL)
                os.close(file)
                gotLock = 1

            except OSError:
                # error 17 is "File exists"
                #(errno, strerror) = xxx_todo_changeme.args
                # error 17 is "File exists"
                #if errno != 17:
                    #raise madrigal.admin.MadrigalError("Unable to open " + filename + ".LCK as locking file ", None)
                # get modification time - may throw an error if file has disappearred
                try:
                    newModTime = (os.stat(filename + '.LCK')).st_mtime
                except:
                    #file has disappeared, no need to sleep
                    continue

                # if the lock file has been modified (or if this is the first time through) set numTries = 0
                if newModTime > modificationTime:
                    modificationTime = newModTime
                    numTries = 0
                    
                time.sleep(1)
                
            numTries = numTries + 1

            if numTries > self._MaxSleep:
                return

       
    def _dropLock(self, filename):
        """_dropLock is a private helper function that drops exclusive access to filename via a locking file.

        Inputs: filename = the file that exclusive access is required to.
        
        Returns: None

        Affects: Removes file filename + .LCK as a lock mechanism

        Exceptions: None.
        """
        try:
            os.remove(filename + '.LCK')

        except IOError:
            return


class MadrigalWebFormat:
    """MadrigalWebFormat defines the format of an web interface.

    Information about how a web page is formatted is stored in this class.  In particular,
    the possible derived parameters to display for a given format (such as Short or
    Comprehensive) are set in this class.  Edit this class to create new formats or
    modify existing ones.

    Non-standard Python modules used:
    None

    No exceptions thrown

    Change history:

    Written by "Bill Rideout":mailto:wrideout@haystack.mit.edu  Oct. 29, 2001
    """

    # constants

    # Edit this data to change which parameters to display
    # or to add new formats
    #
    #                   Format          Parameters      
    #                   ------          ----------  
    _privateDict =  {'Comprehensive':  [   'year',
                                            'month',
                                            'day',
					                        'bmonth',
					                        'bday',
                                            'hour',
                                            'min',
                                            'sec',
                                            'md',
                                            'dayno',
                                            'bhm',
                                            'bhhmmss',
                                            'ehhmmss',
                                            'uth',
                                            'b_uth',
                                            'ut',
                                            'ut1_unix',
                                            'ut2_unix',
                                            'beg_ut',
                                            'slt',
                                            'sltc',
                                            'fyear',
                                            'sunrise_hour',
                                            'sunset_hour',
                                            'conj_sunrise_h',
                                            'conj_sunset_h',
                                            'aplt',
                                            'julian_date',
                                            'gdalt',
                                            'range',
                                            'resl',
                                            'azm',
                                            'az1',
                                            'az2',
                                            'elm',
                                            'el1',
                                            'el2',
                                            'gdlat',
                                            'glon',
                                            'szen',
                                            'szenc',
                                            'sdwht',
                                            'beamid',
                                            'bn',
                                            'be',
                                            'bd',
                                            'magh',
                                            'magd',
                                            'magzu',
                                            'bmag',
                                            'bdec',
                                            'binc',
                                            'lshell',
                                            'diplat',
                                            'invlat',
                                            'aplat',
                                            'aplon',
                                            'e_reg_s_lat',
                                            'e_reg_s_lon',
                                            'e_reg_s_sdwht',
                                            'e_reg_n_lat',
                                            'e_reg_n_lon',
                                            'e_reg_n_sdwht',
                                            'magconjlat',
                                            'magconjlon',
                                            'magconjsdwht',
                                            'mlt',
                                            'tsyg_eq_xgsm',
                                            'tsyg_eq_ygsm',
                                            'tsyg_eq_xgse',
                                            'tsyg_eq_ygse',
                                            'aacgm_lat',
                                            'aacgm_long',
                                            'aspect',
                                            'cxr',
                                            'cyr',
                                            'czr',
                                            'pl',
                                            'snp3',
                                            'chisq',
                                            'gfit',
                                            'mhdqc1',
                                            'systmp',
                                            'systmi',
                                            'power',
                                            'tfreq',
                                            'popl',
                                            'ne',
                                            'nel',
                                            'ti',
                                            'te',
                                            'tr',
                                            'vo',
                                            'ph+',
                                            'pm',
                                            'co',
                                            'vdopp',
                                            'dvdopp',
                                            'dco',
                                            'dpm',
                                            'dph+',
                                            'dvo',
                                            'dtr',
                                            'dte',
                                            'dti',
                                            'dpopl',
                                            'dne',
                                            'ne_model',
                                            'nel_model',
                                            'te_model',
                                            'ti_model',
                                            'vo_model',
                                            'hmax_model',
                                            'nmax_model',
                                            'ne_modeldiff',
                                            'nel_modeldiff',
                                            'te_modeldiff',
                                            'ti_modeldiff',
                                            'vo_modeldiff',
                                            'tn',
                                            'tnm',
                                            'tinfm',
                                            'mol',
                                            'nn2l',
                                            'no2l',
                                            'nol',
                                            'narl',
                                            'nhel',
                                            'nhl',
                                            'nn4sl',
                                            'fa',
                                            'pnrmd',
                                            'pnrmdi',
                                            'ut1',
                                            'ut2',
                                            'dut21',
                                            'kinst',
                                            'recno',
                                            'kindat',
                                            'fof2',
                                            'dfa',
                                            'dst',
                                            'kp',
                                            'ap',
                                            'ap3',
                                            'f10.7',
                                            'fbar',
                                            'pdcon',
                                            'dpdcon',
                                            'hlcon',
                                            'dhlcon',
                                            'ne_iri',
                                            'nel_iri',
                                            'tn_iri',
                                            'te_iri',
                                            'ti_iri',
                                            'po+_iri',
                                            'pno+_iri',
                                            'po2+_iri',
                                            'phe+_iri',
                                            'ph+_iri',
                                            'pn+_iri',
                                            'bxgsm',
                                            'bygsm',
                                            'bzgsm',
                                            'bimf',
                                            'bxgse',
                                            'bygse',
                                            'bzgse',
                                            'swden',
                                            'swspd',
                                            'swq'],
                      'Short':          [   'year',
                                            'md',
                                            'dayno',
                                            'uth',
                                            'b_uth',
                                            'ut',
                                            'beg_ut',
                                            'lt',
                                            'aplt',
                                            'jdayno',
                                            'gdalt',
                                            'range',
                                            'azm',
                                            'az1',
                                            'az2',
                                            'elm',
                                            'el1',
                                            'el2',
                                            'gdlat',
                                            'glon',
                                            'popl',
                                            'nel',
                                            'ti',
                                            'te',
                                            'tr',
                                            'vo',
                                            'ph+',
                                            'pm',
                                            'co',
                                            'vdopp',
                                            'dvdopp',
                                            'dco',
                                            'dpm',
                                            'dph+',
                                            'dvo',
                                            'dtr',
                                            'dte',
                                            'dti',
                                            'dpopl',
                                            'dne',
                                            'kp',
                                            'ap',
                                            'ap3',
                                            'f10.7',
                                            'fbar']}

    def getFormat(self, formatName):
        return self._privateDict[formatName]



</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="madrigal.ui.web.MadrigalWeb" class="name">class <span class="ident">MadrigalWeb</span></p>
      
  
    <div class="desc"><p>MadrigalWeb is the class that produces output for the web.</p>
<p>All text written to the web is produced in this class.</p>
<p>Non-standard Python modules used:
None</p>
<p>Change history:</p>
<p>Written by "Bill Rideout":mailto:wrideout@haystack.mit.edu  Dec. 17, 2001</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb" class="source">
    <pre><code>class MadrigalWeb:
    """MadrigalWeb is the class that produces output for the web.

    All text written to the web is produced in this class.

    Non-standard Python modules used:
    None

    Change history:

    Written by "Bill Rideout":mailto:wrideout@haystack.mit.edu  Dec. 17, 2001
    """
    

    _MaxSleep     = 10

    def __init__(self, madDB = None):
        """__init__ initializes MadrigalWeb by reading from MadridalDB..

        Inputs: Existing MadrigalDB object, by default = None.
        
        Returns: void

        Affects: Initializes self._metaDir, self._logFile.

        Exceptions: None.
        """

        if madDB == None:
            self._madDB = madrigal.metadata.MadrigalDB()
        else:
            self._madDB = madDB

        self._binDir = self._madDB.getBinDir()
        self._instObj = madrigal.metadata.MadrigalInstrument(self._madDB)
        self._madKindatObj = madrigal.metadata.MadrigalKindat(self._madDB)

        metaDir = self._madDB.getMetadataDir()

        # get todays year
        now = datetime.datetime.now()

        thisYear = '%04i' % (now.year)

        self._logFile = os.path.join(metaDir, 'userdata', 'access_%s.log' % (thisYear))

        # be sure it exists
        if not os.access(self._logFile, os.R_OK):
            f=open(self._logFile, 'w')
            f.close()

        # keep track of whether user trusted
        self._isTrusted_ = None
        
        # cache Madrigal objects as needed to imprive performance
        self._madExpObjExpID = None # will be set to a MadrigalExperiment object sorted by expId when first needed
        self._madExpObjDate = None # will be set to a MadrigalExperiment object sorted by date when first needed




    def getRulesOfTheRoad(self, PI=None, PIEmail=None):
        """ getRulesOfTheRoad returns a string giving the rules in html formal for using madrigal data.

        Inputs: PI - contact name. Default is site name.
            PIEmail - email link.  Default is site admin.
        
        Returns: a string giving the rules in html formal for using madrigal data

        Affects: None.

        Exceptions: None.
        """
        if not PI or not PIEmail:
            # get the site name
            siteObj = madrigal.metadata.MadrigalSite(self._madDB)
            siteID = self._madDB.getSiteID()
            contactName = str(siteObj.getSiteName(siteID))
            contactEmail = str(siteObj.getSiteEmail(siteID))
        else:
            contactName = str(PI)
            contactEmail = str(PIEmail)
        
        returnStr = 'Please contact %s at ' % (contactName)

        returnStr = returnStr + '<a href="mailto:' + contactEmail + '">' + \
                    contactEmail + '</a> before using this data in a report or publication.'

        return returnStr
    
        
    def generateLogout(self, fileName, expName):
        """ generateLogout generates a java script which sends a user to the madLogin page to logout automatically.

        Inputs: fileName: the madrigal file to return to
                expName:  the experiment name of the file to return to
        
        Returns: a java script which sends a user to the madLogin page to logout automatically

        Affects: None.

        Exceptions: None.
        """

        print('<script language = "JavaScript">')
        print('\twindow.location = "madLogin?fileName=' + \
              fileName + '&expName=' + \
              expName + '&state=autoLogout"')
        print('</script>')


    def isTrusted(self):
        """ isTrusted returns 1 if browser ip matches any in the trustedIPs.txt file; 0 otherwise.

        Inputs: None
        
        Returns: 1 if browser ip matches any in the trustedIPs.txt file; 0 otherwise.  Also returns
        0 if no browser ip available or trustedIPs.txt cannot be opened.

        Affects: None.

        Exceptions: None.
        """
        if self._isTrusted_ != None:
            return(self._isTrusted_)
        
        try:
            trustFile = open(self._madDB.getMadroot() + '/trustedIPs.txt', 'r')
        except:
            return 0

        # try to read env var REMOTE_ADDR and HTTP_X_FORWARDED_FOR
        userIPList = []
        if os.environ.get('REMOTE_ADDR')!= None:
            userIPList.append(os.environ.get('REMOTE_ADDR'))
        if os.environ.get('HTTP_X_FORWARDED_FOR') != None:
            ips = os.environ.get('HTTP_X_FORWARDED_FOR').split(',')
            for ip in ips:
                userIPList.append(ip.strip())
        if len(userIPList) == 0:
            self._isTrusted_ = 0
            return 0
        if len(userIPList[0]) < 7:
            # ip address too short
            self._isTrusted_ = 0
            return 0

        # loop through trustedIPs.txt to find a match
        ipList = trustFile.readlines()
        for userIP in userIPList:
            for ipItem in ipList:
                # match using filename matching with *
                if fnmatch.fnmatch(userIP, ipItem.strip()):
                    self._isTrusted_ = 1
                    return 1

        # out of loop, no match found
        self._isTrusted_ = 0
        return 0


    def logDataAccess(self, fullFilenameList, user_fullname=None, user_email=None, user_affiliation=None):
        """ logDataAccess logs queries that access low-level data.

        Records user name, email, affiliation, datetime, and full path the file(s) accessed.

        Inputs:

            fullFilenameList either a list of full filenames, or a string with one filename

            user_fullname - if None, try to read from cookie.  Also, any commas replaced by spaces.

            user_email - if None, try to read from cookie.  Also, any commas replaced by spaces.

            user_affiliation - if None, try to read from cookie.  Also, any commas replaced by spaces.
            

        Outputs: None

        Affects: Write line to log file with 5 or more comma-delimited columns.  Example:

            Bill Rideout,brideout@haystack.mit.edu,MIT Haystack,2002-12-25 00:00:00, \
            /opt/madrigal/experiments/2005/mlh/01sep05/mlh050901g.001,/opt/madrigal/experiments/2005/mlh/02sep05/mlh050902g.001

        Uses _getLock and _dropLock to ensure single users access to log file
        """

        if user_fullname == None or user_email == None or user_affiliation == None:
        
            # try to get name, email, affiliation from cookie
            cookie = http.cookies.SimpleCookie()
            if 'HTTP_COOKIE' in os.environ:
                cookie.load(os.environ['HTTP_COOKIE'])
                try:
                    user_fullname = cookie["user_fullname"].value
                    user_email = cookie["user_email"].value
                    user_affiliation = cookie["user_affiliation"].value
                except:
                    # no way to write log
                    return

            if user_fullname == None or user_email == None or user_affiliation == None:
                return

        # strip out any commas
        user_fullname = user_fullname.replace(',', ' ')
        user_email = user_email.replace(',', ' ')
        user_affiliation = user_affiliation.replace(',', ' ')

        if type(fullFilenameList) in (list, tuple):
            delimiter = ','
            fileStr = delimiter.join(fullFilenameList)
        else:
            fileStr = str(fullFilenameList)
        

        now = datetime.datetime.now()


        nowStr = now.strftime('%Y-%m-%d %H-%M-%S')

        # lock out any method that writes to log file
        self._getLock(self._logFile)

        f = open(self._logFile, 'a')

        f.write('%s,%s,%s,%s,%s\n' % (user_fullname.encode('utf8'),
                                      user_email.encode('utf8'),
                                      user_affiliation.encode('utf8'),
                                      nowStr,
                                      fileStr))



        f.close()

        # done with log file - allow access to other writing calls
        self._dropLock(self._logFile)  
        
        
    def filterLog(self, tmpFile, kinstList=None, accessStartDate=None, accessEndDate=None):
        """filterLog writes a subsection of the access log to a temporary file
        
        Inputs:
        
            tmpFile - temporary file to write subsection of log to
            
            kinstList - list of kinsts to accept.  If None (the default), accept all instruments
            
            accessStartDate - if not None (the default), reject all access dates before
                datetime accessStartDate
                
            accessEndDate - if not None (the default), reject all access dates after
                datetime accessEndDate
            
        """
        f = open(tmpFile, 'w')
        
        accessLogs = glob.glob(os.path.join(self._madDB.getMadroot(), 'metadata/userdata/access_*.log'))
        accessLogs.sort()
        
        # addition for cedar only
        """accessLogs2 = glob.glob('/opt/cedar/metadata/userdata/access_*[0-9].log')
        accessLogs += accessLogs2
        accessLogs.sort()"""
        
        
        if kinstList:
            # create a dictionary of key = 3 letter inst mnem, value = kinstList
            instDict = {}
            instList = self._instObj.getInstrumentList()
            for inst in instList:
                if inst[1] in instDict:
                    instDict[inst[1]].append(inst[2])
                else:
                    instDict[inst[1]] = [inst[2]]
        
        for accessLog in accessLogs:
            # see if we can skip this year
            basename = os.path.basename(accessLog)
            year = int(basename[7:-4])
            startYear = datetime.datetime(year,1,1,0,0,0)
            endYear = datetime.datetime(year,12,31,23,59,59)
            if accessStartDate:
                if accessStartDate > endYear:
                    continue
            if accessEndDate:
                if accessEndDate < startYear:
                    continue
            # this file can be huge, so read one line at a time
            fl = open(accessLog)
            while True:
                line = fl.readline()
                if len(line) == 0:
                    break
                items = line.strip().split(',')
                if len(items) != 5:
                    continue
                # walk through filters
                
                # kinst
                if kinstList:
                    # get the instrument mnemonic
                    dirs = items[-1].split('/')
                    found = False
                    try:
                        for kinst in instDict[dirs[-3]]:
                            if kinst in kinstList:
                                found = True
                                break
                    except KeyError:
                        continue
                    if not found:
                        continue
                    
                # access time
                if accessStartDate or accessEndDate:
                    thisDT = datetime.datetime.strptime(items[-2], '%Y-%m-%d %H-%M-%S')
                    if accessStartDate:
                        if accessStartDate > thisDT:
                            continue
                    if accessEndDate:
                        if accessEndDate < thisDT:
                            continue
                        
                # all filters passed
                f.write(line)
                
            fl.close()
                
        f.close()
                
                    
                
        
    def createGlobalIsprintCmd(self, language, madrigalUrl, parmList, output,
                               user_fullname, user_email, user_affiliation,
                               start_datetime, end_datetime, instCode,
                               filterList, kindatList, expName, fileDesc,
                               seasonalStartDate, seasonalEndDate, format=None):
        """createGlobalIsprintCmd returns a string representing a global isprint command to run in a particular language.
        
        Inputs:
        
            language - which language to use.  Allowed values are ('python', 'Matlab', 'IDL')
            madrigalUrl - url to madrigal home page where data is
            parmList - ordered list of parameters requested.
            output - output file name
            user_fullname
            user_email
            user_affiliation
            start_datetime - a datetime object. Reject experiments before that datetime
            end_datetime - a datetime object. Reject experiments after that datetime
            instCode - instrument code (integer)
            filterList - a list of strings in form "mnem,lower,upper" where lower and/or upper may be empty
            kindatList - a list of kindat codes.  An empty list selects all kindats
            expName - filter experiments by the experiment name. Matching is case insensitive and fnmatch characters * and ? are allowed. 
                Empty string is no filtering by experiment name.
            fileDesc - filter files by the file description string. Matching is case insensitive and fnmatch characters * and ? are allowed. 
                Empty string is no filtering by file description.
            seasonalStartDate - a string in form 'MM/DD'.  Dates before then in any year will be ignored.  Assumes non-leap year.
                Empty string means no filtering by seasonal start date.
            seasonalEndDate - a string in form 'MM/DD'.  Dates after then in any year will be ignored.  Assumes non-leap year.
                Empty string means no filtering by seasonal end date.
            format - 'hdf5', 'ascii', or 'netCDF4'. If None, not specified (Madrigal 2 does not support this)
        """
        if language not in ('python', 'Matlab', 'IDL'):
            raise ValueError('language %s not supported' % (str(language)))
        
        # url
        if language == 'python':
            cmd = 'globalIsprint.py --verbose --url=%s ' % (madrigalUrl)
        elif language == 'Matlab':
            cmd = "globalIsprint('%s', ...\n " % (madrigalUrl)
        elif language == 'IDL':
            cmd = "madglobalprint, '%s',  $\n " % (madrigalUrl)
            
        # parms
        if len(parmList) == 0:
            raise ValueError('parmList cannot be empty')
        parmStr = ''
        for parm in parmList:
            parmStr += str(parm)
            if parm != parmList[-1]:
                parmStr += ','
        if language == 'python':
            cmd += '--parms=%s ' % (parmStr)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (parmStr)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (parmStr)
            
        # output
        if language == 'python':
            cmd += '--output=%s ' % (output)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (output)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (output)
            
        # user_fullname
        if language == 'python':
            cmd += '--user_fullname="%s" ' % (user_fullname)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (user_fullname)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (user_fullname)
            
        # user_email
        if language == 'python':
            cmd += '--user_email=%s ' % (user_email)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (user_email)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (user_email)
            
        # user_affiliation
        if language == 'python':
            cmd += '--user_affiliation="%s" ' % (user_affiliation)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (user_affiliation)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (user_affiliation)
            
        
        # start_datetime
        if language == 'python':
            cmd += '--startDate="%s" ' % (start_datetime.strftime('%m/%d/%Y'))
        elif language == 'Matlab':
            cmd += "datenum('%s'), ...\n " % (start_datetime.strftime('%d-%b-%Y %H:%M:%S'))
        elif language == 'IDL':
            cmd += "julday(%i,%i,%i,%i,%i,%i),  $\n " % (start_datetime.month, start_datetime.day,
                                                          start_datetime.year, start_datetime.hour,
                                                          start_datetime.minute, start_datetime.second)
            
        # end_datetime
        if language == 'python':
            cmd += '--endDate="%s" ' % (end_datetime.strftime('%m/%d/%Y'))
        elif language == 'Matlab':
            cmd += "datenum('%s'), ...\n " % (end_datetime.strftime('%d-%b-%Y %H:%M:%S'))
        elif language == 'IDL':
            cmd += "julday(%i,%i,%i,%i,%i,%i),  $\n " % (end_datetime.month, end_datetime.day,
                                                          end_datetime.year, end_datetime.hour,
                                                          end_datetime.minute, end_datetime.second)
            
        # instrument
        if language == 'python':
            cmd += '--inst=%i ' % (instCode)
        elif language == 'Matlab':
            cmd += "%i, ...\n " % (instCode)
        elif language == 'IDL':
            cmd += "%i,  $\n " % (instCode)
            
        # format is here for Matlab or python
        if output == 'example.txt':
            format = None
        if language in ('Matlab', 'python'):
            if language == 'python':
                if not format is None:
                    if format.lower() == 'hdf5':
                        cmd += '--format=%s ' % ('Hdf5')
                    elif format in ('netCDF4', 'ascii'):
                        cmd += '--format=%s ' % (format)
            elif language == 'Matlab':
                if format is None:
                    cmd += "'', ...\n "
                elif format.lower() == 'hdf5':
                    cmd += "'%s', ...\n " % ('Hdf5')
                elif format in ('netCDF4', 'ascii'):
                    cmd += "'%s', ...\n " % (format)
            
        # filterList
        # add seasonal filters if needed 
        if len(seasonalStartDate) or len(seasonalEndDate):
            daynoFilterStr = self._getDaynoFilter(seasonalStartDate, seasonalEndDate)
            filterList.append(daynoFilterStr)
        if language == 'python':
            for filterItem in filterList:
                cmd += '--filter=%s ' % (filterItem)
        elif language == 'Matlab':
            filterStr = ''
            for filterItem in filterList:
                filterStr += 'filter=%s ' % (filterItem)
            cmd += "'%s', ...\n " % (filterStr)
        elif language == 'IDL':
            filterStr = ''
            for filterItem in filterList:
                filterStr += 'filter=%s ' % (filterItem)
            cmd += "'%s',  $\n " % (filterStr)
            
        # kindatList
        if language == 'python':
            if len(kindatList) == 0:
                pass
            else:
                kindatStr = '--kindat='
                for kindat in kindatList:
                    kindatStr += '%i' % (kindat)
                    if kindat != kindatList[-1]:
                        kindatStr += ','
                cmd += '%s ' % (kindatStr)
        elif language == 'Matlab':
            kindatStr = '['
            for kindat in kindatList:
                if kindat == 0:
                    continue
                kindatStr += '%i' % (kindat)
                if kindat != kindatList[-1]:
                    kindatStr += ','
            kindatStr += ']'
            cmd += "%s, ...\n " % (kindatStr)
        elif language == 'IDL':
            # make sure 0 not in list
            try:
                kindatList.remove(0)
            except ValueError:
                pass
            if len(kindatList) == 0:
                kindatStr = 'PTR_NEW()'
            else:
                kindatStr = '['
                for kindat in kindatList:
                    kindatStr += '%i' % (kindat)
                    if kindat != kindatList[-1]:
                        kindatStr += ','
                kindatStr += ']'
            cmd += "%s,  $\n " % (kindatStr)
            
        # expName
        if language == 'python':
            if len(expName) > 0:
                cmd += '--expName="%s" ' % (expName)
        elif language == 'Matlab':
            expName = expName.replace('*', '.*')
            expName = expName.replace('?', '.?')
            cmd += "'%s', ...\n " % (expName)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (expName)
            
        # fileDesc
        if language == 'python':
            if len(fileDesc) > 0:
                cmd += '--fileDesc="%s" ' % (fileDesc)
        elif language == 'Matlab':
            fileDesc = fileDesc.replace('*', '.*')
            fileDesc = fileDesc.replace('?', '.?')
            cmd += "'%s') " % (fileDesc)
        elif language == 'IDL':
            cmd += "'%s',  $\n "  % (fileDesc)
            
        # format is here for idl
        if language == 'IDL':
            if format is None:
                cmd += "'',  $\n "
            elif format.lower() == 'hdf5':
                cmd += "'hdf5',  $\n "
            elif format in ('netCDF4', 'ascii'):
                cmd += "'%s',  $\n "  % (format)
            
            
            
        return(cmd)
    
    
    
    def createGlobalDownloadCmd(self, language, madrigalUrl, output, format,
                               user_fullname, user_email, user_affiliation,
                               start_datetime, end_datetime, instCode,
                               kindatList, expName, fileDesc):
        """createGlobalDownloadCmd returns a string representing a global download as is command to run in a particular language.
        
        Inputs:
        
            language - which language to use.  Allowed values are ('python', 'Matlab', 'IDL')
            madrigalUrl - url to madrigal home page where data is
            output - output directory name
            format - 'hdf5', 'ascii', or 'netCDF4'
            user_fullname
            user_email
            user_affiliation
            start_datetime - a datetime object. Reject experiments before that datetime
            end_datetime - a datetime object. Reject experiments after that datetime
            instCode - instrument code (integer)
            kindatList - a list of kindat codes.  An empty list selects all kindats
            expName - filter experiments by the experiment name. Matching is case insensitive and fnmatch characters * and ? are allowed. 
                Empty string is no filtering by experiment name.
            fileDesc - filter files by the file description string. Matching is case insensitive and fnmatch characters * and ? are allowed. 
                Empty string is no filtering by file description.
        """
        if language not in ('python', 'Matlab', 'IDL'):
            raise ValueError('language %s not supported' % (str(language)))
        
        # url
        if language == 'python':
            cmd = 'globalDownload.py --verbose --url=%s ' % (madrigalUrl)
        elif language == 'Matlab':
            cmd = "globalDownload('%s', ...\n " % (madrigalUrl)
        elif language == 'IDL':
            cmd = "madglobaldownload, '%s',  $\n " % (madrigalUrl)
            
        # output
        if language == 'python':
            cmd += '--outputDir=%s ' % (output)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (output)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (output)
            
        # user_fullname
        if language == 'python':
            cmd += '--user_fullname="%s" ' % (user_fullname)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (user_fullname)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (user_fullname)
            
        # user_email
        if language == 'python':
            cmd += '--user_email=%s ' % (user_email)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (user_email)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (user_email)
            
        # user_affiliation
        if language == 'python':
            cmd += '--user_affiliation="%s" ' % (user_affiliation)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (user_affiliation)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (user_affiliation)
            
        # format part 1 (format is not in same order in Matlab and IDL)
        if format not in ('hdf5', 'ascii', 'netCDF4'):
            raise ValueError('format not in hdf5, ascii or netCDF4')
        if language == 'python':
            cmd += '--format="%s" ' % (format)
        elif language == 'Matlab':
            cmd += "'%s', ...\n " % (format)
        
        # start_datetime
        if language == 'python':
            cmd += '--startDate="%s" ' % (start_datetime.strftime('%m/%d/%Y'))
        elif language == 'Matlab':
            cmd += "datenum('%s'), ...\n " % (start_datetime.strftime('%d-%b-%Y %H:%M:%S'))
        elif language == 'IDL':
            cmd += "julday(%i,%i,%i,%i,%i,%i),  $\n " % (start_datetime.month, start_datetime.day,
                                                          start_datetime.year, start_datetime.hour,
                                                          start_datetime.minute, start_datetime.second)
            
        # end_datetime
        if language == 'python':
            cmd += '--endDate="%s" ' % (end_datetime.strftime('%m/%d/%Y'))
        elif language == 'Matlab':
            cmd += "datenum('%s'), ...\n " % (end_datetime.strftime('%d-%b-%Y %H:%M:%S'))
        elif language == 'IDL':
            cmd += "julday(%i,%i,%i,%i,%i,%i),  $\n " % (end_datetime.month, end_datetime.day,
                                                          end_datetime.year, end_datetime.hour,
                                                          end_datetime.minute, end_datetime.second)
            
        # instrument
        if language == 'python':
            cmd += '--inst=%i ' % (instCode)
        elif language == 'Matlab':
            cmd += "%i, ...\n " % (instCode)
        elif language == 'IDL':
            cmd += "%i,  $\n " % (instCode)
            
            
        # kindatList
        if language == 'python':
            if len(kindatList) == 0:
                pass
            else:
                kindatStr = '--kindat='
                for kindat in kindatList:
                    kindatStr += '%i' % (kindat)
                    if kindat != kindatList[-1]:
                        kindatStr += ','
                cmd += '%s ' % (kindatStr)
        elif language == 'Matlab':
            kindatStr = '['
            for kindat in kindatList:
                if kindat == 0:
                    continue
                kindatStr += '%i' % (kindat)
                if kindat != kindatList[-1]:
                    kindatStr += ','
            kindatStr += ']'
            cmd += "%s, ...\n " % (kindatStr)
        elif language == 'IDL':
            # make sure 0 not in list
            try:
                kindatList.remove(0)
            except ValueError:
                pass
            if len(kindatList) == 0:
                kindatStr = 'PTR_NEW()'
            else:
                kindatStr = '['
                for kindat in kindatList:
                    kindatStr += '%i' % (kindat)
                    if kindat != kindatList[-1]:
                        kindatStr += ','
                kindatStr += ']'
            cmd += "%s,  $\n " % (kindatStr)
            
            
        # now deal with IDL format if needed
        if language == 'IDL':
            cmd += "'%s',  $\n " % (format)
            
        # expName
        if language == 'python':
            if len(expName) > 0:
                cmd += '--expName="%s" ' % (expName)
        elif language == 'Matlab':
            expName = expName.replace('*', '.*')
            expName = expName.replace('?', '.?')
            cmd += "'%s', ...\n " % (expName)
        elif language == 'IDL':
            cmd += "'%s',  $\n " % (expName)
            
        # fileDesc
        if language == 'python':
            if len(fileDesc) > 0:
                cmd += '--fileDesc="%s" ' % (fileDesc)
        elif language == 'Matlab':
            fileDesc = fileDesc.replace('*', '.*')
            fileDesc = fileDesc.replace('?', '.?')
            cmd += "'%s') " % (fileDesc)
        elif language == 'IDL':
            cmd += "'%s' " % (fileDesc)
            
        return(cmd)
    
    
    def generateGlobalIsprintScriptFromForm(self, form1, form2, form3, user_fullname,
                                            user_email, user_affiliation):
        """generateGlobalIsprintScriptFromForm converts the three Django forms into arguments so that
        if can then call createGlobalIsprintCmd. Separate forms used because some parts are created by
        Ajax.
        
        form1 is a dict with keys:
            instruments, start_date, end_date, format_select, directory_select, language_select, kindat_select,
            expName, fileDesc, seasonalStartDay, seasonalStartMonth, seasonalEndDay, seasonalEndMonth
        form2 is a dict with keys parameters
        form3 is a dict with keys parm_#, parm_#_lower, parm_#_upper, where # is 1, 2, and 3
        user_fullname, user_email, user_affiliation - strings
            
        """
        instCode = int(form1['instruments'])
        start_datetime = datetime.datetime(form1['start_date'].year, form1['start_date'].month, form1['start_date'].day)
        end_datetime = datetime.datetime(form1['end_date'].year, form1['end_date'].month, form1['end_date'].day)
        format = form1['format_select']
        if format == 'ascii' and form1['directory_select'] == 'File':
            output = 'example.txt'
        else:
            output = '/tmp'
        language = form1['language_select']
        kindatList = [int(kindat) for kindat in form1['kindat_select']]
        expName = form1['expName'].strip()
        fileDesc = form1['fileDesc'].strip()
        seasonalStartDay = int(form1['seasonalStartDay'])
        seasonalStartMonth = int(form1['seasonalStartMonth'])
        seasonalEndDay = int(form1['seasonalEndDay'])
        seasonalEndMonth = int(form1['seasonalEndMonth'])
        if seasonalStartDay == 1 and seasonalStartMonth == 1 and \
            seasonalEndDay == 31 and seasonalEndMonth == 12:
            seasonalStartDate = ''
            seasonalEndDate = ''
        else:
            seasonalStartDate = '%02i/%02i' % (seasonalStartMonth, seasonalStartDay)
            seasonalEndDate = '%02i/%02i' % (seasonalEndMonth, seasonalStartDay)
        madrigalUrl = self._madDB.getTopLevelUrl()
        parmList = form2['parameters']
        filterList = []
        for i in (1,2,3):
            try:
                parm = form3['parm_%i' % (i)]
            except KeyError:
                continue
            if len(parm) == 0:
                continue
            filterStr = '%s,' % (parm)
            try:
                parm_lower = form3['parm_%i_lower' % (i)]
                filterStr += '%s,' % (str(parm_lower))
            except KeyError:
                filterStr += ','
            try:
                parm_upper = form3['parm_%i_upper' % (i)]
                filterStr += '%s' % (str(parm_upper))
            except KeyError:
                pass
            filterList.append(filterStr)
            
            
        return(self.createGlobalIsprintCmd(language, madrigalUrl, parmList, output,
                                           user_fullname, user_email, user_affiliation,
                                           start_datetime, end_datetime, instCode,
                                           filterList, kindatList, expName, fileDesc,
                                           seasonalStartDate, seasonalEndDate, format))
    
    
    def generateDownloadFileScriptFromForm(self, form, user_fullname,
                                           user_email, user_affiliation):
        """generateDownloadFileScriptFromForm converts the Django form into arguments so that
        if can then call createGlobalDownloadCmd.
        
        form is a dict with keys:
            instruments, start_date, end_date, format_select, language_select, kindat_select,
            expName, fileDesc
        user_fullname, user_email, user_affiliation - strings
            
        """
        instCode = int(form['instruments'])
        start_datetime = datetime.datetime(form['start_date'].year, form['start_date'].month, form['start_date'].day)
        end_datetime = datetime.datetime(form['end_date'].year, form['end_date'].month, form['end_date'].day)
        format = form['format_select']
        language = form['language_select']
        kindatList = [int(kindat) for kindat in form['kindat_select']]
        expName = form['expName'].strip()
        fileDesc = form['fileDesc'].strip()
        madrigalUrl = self._madDB.getTopLevelUrl()
        return(self.createGlobalDownloadCmd(language, madrigalUrl, '/tmp', format,
                               user_fullname, user_email, user_affiliation,
                               start_datetime, end_datetime, instCode,
                               kindatList, expName, fileDesc))
    
    
    def getSingleRedirectList(self):
        """getSingleRedirectList returns a list with tuples (kinst, url) where url is url to redirect single UI
        to if instrument not local. If no redirect needed because instrument local, url is empty string
        """
        madInstData = madrigal.metadata.MadrigalInstrumentData(self._madDB, True)
        siteObj = madrigal.metadata.MadrigalSite(self._madDB)
        siteID = self._madDB.getSiteID()
        
        # create a dict with key = siteID, value = redirect url for speed
        getStr = '?isGlobal=True&categories=%i&instruments=%i'
        addUrl = django.urls.reverse('view_single')
        cedarUrl = 'http://cedar.openmadrigal.org/' + addUrl + getStr
        siteDict = {}
        for thisSiteID, siteDesc in siteObj.getSiteList():
            if thisSiteID == siteID:
                siteDict[thisSiteID] = '' # local case
            elif siteObj.getSiteVersion(thisSiteID) == '2.6':
                # redirect to cedar because other site below Madrigal 3
                siteDict[thisSiteID] = cedarUrl
            else:
                siteDict[thisSiteID] = 'http://' + siteObj.getSiteServer(thisSiteID)
                secondPart = siteObj.getSiteDocRoot(thisSiteID) + addUrl + getStr
                if secondPart[0] == '/':
                    siteDict[thisSiteID] += secondPart
                else:
                    siteDict[thisSiteID] += '/' + secondPart
        
        
        retList = []
        for kinst, desc, thisSiteID in madInstData.getInstruments():
            if len(siteDict[thisSiteID]) > 0:
                if siteDict[thisSiteID].find('=%i') != -1:
                    url = siteDict[thisSiteID] % (self._instObj.getCategoryId(kinst), kinst)
                else:
                    url = siteDict[thisSiteID]
            else:
                url = ''
            retList.append((kinst, url))
            
        return(retList)
    
    
    def getMonths(self, kinst, year, optimize=True):
        """getMonths returns a list of tuples of (monthNumber, monthName) where monthNumber
        is 1-12, and monthName is the form January, Febuary, etc. for the the months where
        there is local data for kinst & year combination
        
        Inputs:
            kinst - instrument id (int)
            year - year (int)
            optimize - if True, only start search at beginning of year.  But may miss long experiments,
                so if optimization if False, starts at beginning
        """
        tempDict = {} # dict with key = month number, value = month name
        sDT = datetime.datetime(year,1,1)
        eDT = datetime.datetime(year,12,31,23,59,59)
        madroot = self._madDB.getMadroot()
        if self._madExpObjDate is None:
            self._madExpObjDate = madrigal.metadata.MadrigalExperiment(self._madDB)
        if optimize:
            startIndex = self._madExpObjDate.getStartPosition(sDT)
        else:
            startIndex = 0
        for i in range(startIndex, self._madExpObjDate.getExpCount()):
            thisKinst = self._madExpObjDate.getKinstByPosition(i)
            if kinst != thisKinst:
                continue
            thisSDTList = self._madExpObjDate.getExpStartDateTimeByPosition(i)
            thisSDT = datetime.datetime(*thisSDTList[0:6])
            thisEDTList = self._madExpObjDate.getExpEndDateTimeByPosition(i)
            thisEDT = datetime.datetime(*thisEDTList[0:6])
            if thisEDT < sDT:
                continue
            if thisSDT > eDT:
                continue
            # check for security
            security = self._madExpObjDate.getSecurityByPosition(i)
            if not self.isTrusted(): 
                if security not in (0,2):
                    continue
            else:
                if security not in (0,1,2,3):
                    continue
            if thisSDT.year == year:
                startMonth = thisSDT.month
            else:
                startMonth = 1
            if thisEDT.year == year:
                endMonth = thisEDT.month
            else:
                endMonth = 12
            monthList = list(range(startMonth, endMonth + 1))
            for thisMonth in monthList:
                if thisMonth not in list(tempDict.keys()):
                    tempDict[thisMonth] = calendar.month_name[thisMonth]
                
        monthKeys = list(tempDict.keys())
        monthKeys.sort()
        retList = [(monthKey, tempDict[monthKey]) for monthKey in monthKeys]
        return(retList)
    
    
    def getDays(self, kinst, year, month=None, optimize=True):
        """getDays returns a sorted list of datetime.date objects where
        there is local data for kinst & year & possibly month combination
        
        Inputs:
            kinst - instrument id (int)
            year - year (int)
            month (1-12) if None, include all months
            optimize - if True, only start search at beginning of year.  But may miss long experiments,
                so if optimization if False, starts at beginning
        """
        retList = []
        sDT = datetime.datetime(year,1,1)
        eDT = datetime.datetime(year,12,31,23,59,59)
        if self._madExpObjDate is None:
            self._madExpObjDate = madrigal.metadata.MadrigalExperiment(self._madDB)
        if optimize:
            startIndex = self._madExpObjDate.getStartPosition(sDT)
        else:
            startIndex = 0
        for i in range(startIndex, self._madExpObjDate.getExpCount()):
            thisKinst = self._madExpObjDate.getKinstByPosition(i)
            if kinst != thisKinst:
                continue
            thisSDTList = self._madExpObjDate.getExpStartDateTimeByPosition(i)
            thisSDT = datetime.datetime(*thisSDTList[0:6])
            thisEDTList = self._madExpObjDate.getExpEndDateTimeByPosition(i)
            thisEDT = datetime.datetime(*thisEDTList[0:6])
            if thisEDT < sDT:
                continue
            if thisSDT > eDT:
                continue
            # check for security
            security = self._madExpObjDate.getSecurityByPosition(i)
            if not self.isTrusted():
                if security not in (0,2):
                    continue
            else:
                if security not in (0,1,2,3):
                    continue
            # loop over all days
            delta = datetime.timedelta(days=1)
            loopDT = max(sDT, datetime.datetime(thisSDT.year, thisSDT.month, thisSDT.day))
            while (loopDT <= thisEDT):
                if loopDT > eDT:
                    break
                if not month is None:
                    if month > loopDT.month:
                        loopDT += delta
                        continue
                    elif month < loopDT.month:
                        break
                thisDate = loopDT.date()
                if thisDate not in retList:
                    retList.append(thisDate)
                loopDT += delta
                
                
        retList.sort()
        return(retList)
    
    
    
    def getExperimentList(self, kinstList, startDT, endDT, localOnly):
        """getExperimentList returns a sorted list of tuples of (expId, expUrl, expName, instName, kinst, 
        expStartDT, expEndDT, siteId, siteName)
        
        Inputs:
            kinstList -  a list of instrument id (int) - may include 0
            startDT - start datetime to search
            endDT - end datetime to search
            localOnly - if True, only search locally. If False, search globally
        """
        retList = []
        madroot = self._madDB.getMadroot()
        siteId = self._madDB.getSiteID()
        siteObj = madrigal.metadata.MadrigalSite(self._madDB)
        if localOnly:
            expTabFile = os.path.join(madroot, 'metadata/expTab.txt')
        else:
            expTabFile = os.path.join(madroot, 'metadata/expTabAll.txt')
        madExpObjDate = madrigal.metadata.MadrigalExperiment(self._madDB, expTabFile)
        startIndex = madExpObjDate.getStartPosition(startDT)
        for i in range(startIndex, madExpObjDate.getExpCount()):
            thisKinst = madExpObjDate.getKinstByPosition(i)
            if thisKinst not in kinstList and 0 not in kinstList:
                continue
            thisSDTList = madExpObjDate.getExpStartDateTimeByPosition(i)
            thisSDT = datetime.datetime(*thisSDTList[0:6])
            thisEDTList = madExpObjDate.getExpEndDateTimeByPosition(i)
            thisEDT = datetime.datetime(*thisEDTList[0:6])
            if thisEDT < startDT:
                continue
            if thisSDT > endDT:
                break
            # check for security
            security = madExpObjDate.getSecurityByPosition(i)
            if not self.isTrusted():
                if security not in (0,2):
                    continue
            else:
                if security not in (0,1,2,3):
                    continue
            thisSiteId = madExpObjDate.getExpSiteIdByPosition(i)
            if siteId == thisSiteId:
                isLocal = True
            else:
                isLocal = False
            thisExpId = madExpObjDate.getExpIdByPosition(i)
            thisExpPath = madExpObjDate.getExpPathByPosition(i)
            thisExpName = madExpObjDate.getExpNameByPosition(i)
            if isLocal:
                thisExpUrl = django.urls.reverse('show_experiment') + \
                    '?experiment_list=%i' % (thisExpId)
            elif siteObj.getSiteVersion(thisSiteId) == '2.6':
                thisExpUrl = 'http://' + os.path.join(siteObj.getSiteServer(thisSiteId),
                                          siteObj.getSiteRelativeCGI(thisSiteId),
                                          'madExperiment.cgi?exp=%s' % (thisExpPath))
                thisExpUrl += '&displayLevel=0&expTitle=%s' % (django.utils.http.urlquote(thisExpName))
            else:
                # remote Madrigal 3.0 site
                baseUrl = os.path.basename(django.urls.reverse('show_experiment')[:-1])
                thisExpUrl = baseUrl + '?experiment_list=%s' % (thisExpPath)
                thisSiteUrl = 'http://%s' % (siteObj.getSiteServer(thisSiteId))
                relativeUrl = siteObj.getSiteDocRoot(thisSiteId)
                if relativeUrl not in ('', None):
                    thisSiteUrl = os.path.join(thisSiteUrl, relativeUrl)
                if thisSiteUrl[-1] != '/' and thisExpUrl[0] != '/':
                    thisSiteUrl += '/'
                thisExpUrl = thisSiteUrl + thisExpUrl
                
            thisSiteName = siteObj.getSiteName(thisSiteId)
            instName = self._instObj.getInstrumentName(thisKinst)
            
            retList.append((thisExpId, thisExpUrl, thisExpName, instName, thisKinst, 
                            thisSDT.strftime('%Y-%m-%d %H:%M:%S'), thisEDT.strftime('%Y-%m-%d %H:%M:%S'),
                            thisSiteId, thisSiteName))
                
        return(retList)
    
    
    
    def getExpsOnDate(self, kinst, year, month, day, optimize=True):
        """getExpsOnDate returns a sorted list of tuples of (expId, expDesc, expDir, pi_name, pi_email)
        
        Inputs:
            kinst - instrument id (int)
            year - year (int)
            month - month (int)
            day - day (int)
            optimize - if True, only start search at beginning of day.  But may miss long experiments,
                so if optimization if False, starts at beginning
        """
        retList = []
        sDT = datetime.datetime(year,month,day)
        eDT = datetime.datetime(year,month,day,23,59,59)
        if self._madExpObjDate is None:
            self._madExpObjDate = madrigal.metadata.MadrigalExperiment(self._madDB)
        if optimize:
            startIndex = self._madExpObjDate.getStartPosition(sDT)
        else:
            startIndex = 0
        for i in range(startIndex, self._madExpObjDate.getExpCount()):
            thisKinst = self._madExpObjDate.getKinstByPosition(i)
            if kinst != thisKinst:
                continue
            thisSDTList = self._madExpObjDate.getExpStartDateTimeByPosition(i)
            thisSDT = datetime.datetime(*thisSDTList[0:6])
            thisEDTList = self._madExpObjDate.getExpEndDateTimeByPosition(i)
            thisEDT = datetime.datetime(*thisEDTList[0:6])
            if thisEDT < sDT:
                continue
            if thisSDT > eDT:
                continue
            # check for security
            security = self._madExpObjDate.getSecurityByPosition(i)
            if not self.isTrusted():
                if security not in (0,2):
                    continue
            else:
                if security not in (0,1,2,3):
                    continue
            thisExpId = self._madExpObjDate.getExpIdByPosition(i)
            thisExpName = self._madExpObjDate.getExpNameByPosition(i)
            thisExpDesc = '%s: %s-%s' % (thisExpName, thisSDT.strftime('%Y-%m-%d %H:%M:%S'),
                                         thisEDT.strftime('%Y-%m-%d %H:%M:%S'))
            thisExpDir = self._madExpObjDate.getExpDirByPosition(i)
            thisExpPI = self._madExpObjDate.getPIByPosition(i)
            thisExpPIEmail = self._madExpObjDate.getPIEmailByPosition(i)
            if thisExpPI in (None, ''):
                thisExpPI = self._instObj.getContactName(kinst)
                thisExpPIEmail = self._instObj.getContactEmail(kinst)
            retList.append((thisExpId, thisExpDesc, thisExpDir))
                
        return(retList)
    
    
    
    def getFileFromExpDir(self, expDir, kinst, includeNonDefault=False):
        """getFileFromExpDir returns a list of tuples of (basename, fileDesc)
        
        Inputs:
            expDir - full path to exp directory
            kinst - instrument id (used to look up kindat descriptions)
            includeNonDefault - if True, include variant and history files.  If False
                (the default), do not
        """
        retList = []
        realTimeList = [] # in case no default files
        if not os.access(os.path.join(expDir, 'fileTab.txt'), os.R_OK):
            # no files in this experiment
            return(retList)
        madFileObj = madrigal.metadata.MadrigalMetaFile(self._madDB, os.path.join(expDir, 'fileTab.txt'))
        for i in range(madFileObj.getFileCount()):
            if madFileObj.getAccessByPosition(i) == 1 and not self.isTrusted():
                continue
            category = madFileObj.getCategoryByPosition(i)
            if category in (2,3) and not includeNonDefault:
                continue
            basename = madFileObj.getFilenameByPosition(i)
            kindat = madFileObj.getKindatByPosition(i)
            kindatDesc = self._madKindatObj.getKindatDescription(kindat, kinst)
            status = madFileObj.getStatusByPosition(i)
            fileDesc = '%s: %s - %s' % (basename, kindatDesc, status)
            if category != 4:
                retList.append((basename, fileDesc))
            else:
                realTimeList.append((basename, fileDesc))
            
        if len(retList) > 0:
            return(retList)
        else:
            return(realTimeList)
        
    
    def getExpInfoFromExpID(self, expID):
        """getExpInfoFromExpID returns a tuple of (pi_name, pi_email, expUrl, kinst, expDesc, kinstDesc) for given expID
        
        expUrl is url from getRealExpUrlByExpId
        
        Inputs:
            expID - experimentID (int)
        """
        expID = int(expID)
        if self._madExpObjExpID is None:
            self._madExpObjExpID = madrigal.metadata.MadrigalExperiment(self._madDB)
        kinst = self._madExpObjExpID.getKinstByExpId(expID)
        kinstDesc = self._instObj.getInstrumentName(kinst)
        expPI = self._madExpObjExpID.getPIByExpId(expID)
        expPIEmail = self._madExpObjExpID.getPIEmailByExpId(expID)
        expUrl = self._madExpObjExpID.getRealExpUrlByExpId(expID)
        if expPI in (None, ''):
            expPI = self._instObj.getContactName(kinst)
            expPIEmail = self._instObj.getContactEmail(kinst)
        thisSDTList = self._madExpObjExpID.getExpStartDateTimeByExpId(expID)
        thisSDT = datetime.datetime(*thisSDTList[0:6])
        thisEDTList = self._madExpObjExpID.getExpEndDateTimeByExpId(expID)
        thisEDT = datetime.datetime(*thisEDTList[0:6])
        thisExpName = self._madExpObjExpID.getExpNameByExpId(expID)
        thisExpDesc = '%s: %s-%s' % (thisExpName, thisSDT.strftime('%Y-%m-%d %H:%M:%S'),
                                     thisEDT.strftime('%Y-%m-%d %H:%M:%S'))
        
        return((expPI, expPIEmail, expUrl, kinst, thisExpDesc, kinstDesc))
    
    
    def getExpIDFromExpPath(self, expPath, matchAnyExpNum=False):
        """getExpIDFromExpPath returns the expId for given expPath (starts with 'experiments')
        
        If matchAnyExpNum is False, it will only match the right experiments* directory (default).
        It True, matches via re to experiments[0-9]*/<remaining exp path>
        
        Returns None if not found
        
        Inputs:
            expPath - experiment path (starts with 'experiments')
        """
        madExpObj = madrigal.metadata.MadrigalExperiment(self._madDB)
        if matchAnyExpNum:
            expPathRE = 'experiments[0-9]*/' + expPath[expPath.find('/')+1:]
        for i in range(madExpObj.getExpCount()):
            if not matchAnyExpNum:
                if madExpObj.getExpPathByPosition(i) == expPath:
                    return(madExpObj.getExpIdByPosition(i))
            else:
                if len(re.findall(expPathRE, madExpObj.getExpPathByPosition(i))) > 0:
                    return(madExpObj.getExpIdByPosition(i))
        
        return(None)
    
    
    def getInfoFromFile(self, filePath):
        """getInfoFromFile returns a tuple of (expName, kindatDesc) for a given input file
        """
        expDir = os.path.dirname(filePath)
        basename = os.path.basename(filePath)
        madExpObj = madrigal.metadata.MadrigalExperiment(self._madDB, os.path.join(expDir, 'expTab.txt'))
        expName = madExpObj.getExpNameByPosition(0)
        kinst = madExpObj.getKinstByPosition(0)
        madFileObj = madrigal.metadata.MadrigalMetaFile(self._madDB, os.path.join(expDir, 'fileTab.txt'))
        kindat = madFileObj.getKindatByFilename(basename)
        kindatDesc = self._madKindatObj.getKindatDescription(kindat, kinst)
        return((expName, kindatDesc))
        
        
        
        
    def getFileFromExpID(self, expID, includeNonDefault=False):
        """getFileFromExpDir returns a list of tuples of (basename, fileDesc)
        
        Inputs:
            expID - experimentID (int)
            includeNonDefault - if True, include variant and history files.  If False
                (the default), do not
        """
        retList = []
        realTimeList = [] # in case no default files
        if self._madExpObjExpID is None:
            self._madExpObjExpID = madrigal.metadata.MadrigalExperiment(self._madDB)
        expDir = self._madExpObjExpID.getExpDirByExpId(expID)
        kinst = self._madExpObjExpID.getKinstByExpId(expID)
        
        if not os.access(os.path.join(expDir, 'fileTab.txt'), os.R_OK):
            # no files in this experiment
            return(retList)
        
        madFileObj = madrigal.metadata.MadrigalMetaFile(self._madDB, os.path.join(expDir, 'fileTab.txt'))
        for i in range(madFileObj.getFileCount()):
            if madFileObj.getAccessByPosition(i) == 1 and not self.isTrusted():
                continue
            category = madFileObj.getCategoryByPosition(i)
            if category in (2,3) and not includeNonDefault:
                continue
            if category == 2:
                categoryStr = '<variant file> '
            elif category == 3:
                categoryStr = '<history file> '
            else:
                categoryStr = ''
            basename = madFileObj.getFilenameByPosition(i)
            kindat = madFileObj.getKindatByPosition(i)
            kindatDesc = self._madKindatObj.getKindatDescription(kindat, kinst)
            status = madFileObj.getStatusByPosition(i)
            fileDesc = '%s: %s%s - %s' % (basename, categoryStr, kindatDesc, status)
            if category != 4:
                retList.append((basename, fileDesc))
            else:
                realTimeList.append((basename, fileDesc))
            
        if len(retList) > 0:
            return(retList)
        else:
            return(realTimeList)
        
        
    def getSiteInfo(self):
        """getSiteInfo returns a tuple of two items:
            1. local site name
            2. list of tuples of (siteName, url) of non-local sites
        """
        siteID = self._madDB.getSiteID()
        siteObj = madrigal.metadata.MadrigalSite(self._madDB)
        siteName = siteObj.getSiteName(siteID)
        retList = []
        siteList = siteObj.getSiteList()
        for thisSiteID, thisSiteName in siteList:
            if thisSiteID == siteID:
                continue
            thisSiteServer = siteObj.getSiteServer(thisSiteID)
            thisSiteDocRoot = siteObj.getSiteDocRoot(thisSiteID)
            thisSiteUrl = urllib.parse.urlunparse(('http', thisSiteServer, thisSiteDocRoot, '','',''))
            retList.append((thisSiteName, thisSiteUrl))
        return((siteName, retList))
    
    
    def downloadFileAsIs(self, expId, basename, user_fullname, user_email, user_affiliation):
        """downloadFileAsIs returns a path to a Madrigal file to download as is (that is, with parms in file, and no filters)
        
        Inputs:
            expId - experiment id of experiment
            basename - basename of file.  May have .txt or .nc extension, in which case Hdf5 file is converted
            user_fullname, user_email, user_affiliation - user identification strings
        """
        self.cleanStage()
        hdf5Extensions = ('.hdf5', '.h5', '.hdf')
        fileName, fileExtension = os.path.splitext(basename)
        if self._madExpObjExpID is None:
            self._madExpObjExpID = madrigal.metadata.MadrigalExperiment(self._madDB)
        expDir = self._madExpObjExpID.getExpDirByExpId(int(expId))
        if expDir is None:
            raise ValueError('No expDir found for exp_id %i' % (int(expId)))
        if fileExtension in hdf5Extensions:
            baseHdf5 = basename
        else:
            # we need to search for the hdf5 basename
            madFileObj = madrigal.metadata.MadrigalMetaFile(self._madDB, os.path.join(expDir, 'fileTab.txt'))
            baseHdf5 = None
            for i in range(madFileObj.getFileCount()):
                thisFileName, thisFileExt = os.path.splitext(madFileObj.getFilenameByPosition(i))
                if thisFileName == fileName and thisFileExt in hdf5Extensions:
                    baseHdf5 = madFileObj.getFilenameByPosition(i)
                    break
        if baseHdf5 is None:
            raise ValueError('No valid file for %s found in %s' % (basename, expDir))
        if basename == baseHdf5:
            fullFilename = os.path.join(expDir, basename)
            fullHdf5Filename = fullFilename
            tmpDir = None
        else:
            fullHdf5Filename = os.path.join(expDir, baseHdf5)
            # create tmp dir if needed
            tmpDir = os.path.join(self._madDB.getMadroot(), 'experiments/stage')
            try:
                os.mkdir(tmpDir)
            except:
                pass
            fullFilename = os.path.join(tmpDir, basename)
            if os.access(fullFilename, os.R_OK):
                try:
                    os.remove(fullFilename)
                except:
                    pass
            if fileExtension == '.txt':
                cachedFile = os.path.join(expDir, 'overview', baseHdf5 + '.txt.gz')
                if os.access(cachedFile, os.R_OK):
                    fullFilename += '.gz'
                    shutil.copy(cachedFile, fullFilename)
                else:
                    madrigal.cedar.convertToText(fullHdf5Filename, fullFilename)
            elif fileExtension == '.nc':
                cachedFile = os.path.join(expDir, 'overview', baseHdf5 + '.nc')
                if os.access(cachedFile, os.R_OK):
                    shutil.copy(cachedFile, fullFilename)
                else:
                    try:
                        madrigal.cedar.convertToNetCDF4(fullHdf5Filename, fullFilename)
                    except IOError:
                        cedarObj = madrigal.cedar.MadrigalCedarFile(fullHdf5Filename)
                        cedarObj.write('netCDF4', fullFilename)
                
        # log access
        self.logDataAccess(fullHdf5Filename, user_fullname, user_email, user_affiliation)
        
        return(fullFilename)
    
    
    
    def downloadFullFileAsIs(self, fullHdf5Filename, format, user_fullname, user_email, user_affiliation):
        """downloadFullFileAsIs is similar to downloadFileAsIs with fullFilename input instead of expId .
        
        Returns a path to a Madrigal file to download as is (that is, with parms in file, and no filters)
        
        Inputs:
            fullHdf5Filename - full path to Madrigal Hdf5 file
            format - 'hdf5', 'netCDF4', or 'ascii'
            user_fullname, user_email, user_affiliation - user identification strings
        """
        self.cleanStage()
        if format not in ('hdf5', 'netCDF4', 'ascii'):
            raise ValueError('Illegal format %s' % (str(format)))
        if not os.access(fullHdf5Filename, os.R_OK):
            raise IOError('Unable to find Hdf5 file %s' % (str(fullHdf5Filename)))
        if format == 'hdf5':
            fullFilename = fullHdf5Filename
            tmpDir = None
        else:
            # dynamically create file
            if format == 'netCDF4':
                thisExt = '.nc'
            elif format == 'ascii':
                thisExt = '.txt'
            # create tmp dir if needed
            tmpDir = os.path.join(self._madDB.getMadroot(), 'experiments/stage')
            try:
                os.mkdir(tmpDir)
            except:
                pass
            base, file_extension = os.path.splitext(fullHdf5Filename)
            basename = os.path.basename(base + thisExt)
            fullFilename = os.path.join(tmpDir, basename)
            if os.access(fullFilename, os.R_OK):
                try:
                    os.remove(fullFilename)
                except:
                    pass

            if format == 'ascii':
                cachedFile = os.path.join(os.path.dirname(fullHdf5Filename), 'overview', 
                                          os.path.basename(fullHdf5Filename) + '.txt.gz')
                if os.access(cachedFile, os.R_OK):
                    fullFilename += '.gz'
                    shutil.copy(cachedFile, fullFilename)
                else:
                    madrigal.cedar.convertToText(fullHdf5Filename, fullFilename)
            elif format == 'netCDF4':
                cachedFile = os.path.join(os.path.dirname(fullHdf5Filename), 'overview', 
                                          os.path.basename(fullHdf5Filename) + '.nc')
                if os.access(cachedFile, os.R_OK):
                    shutil.copy(cachedFile, fullFilename)
                else:
                    try:
                        madrigal.cedar.convertToNetCDF4(fullHdf5Filename, fullFilename)
                    except IOError:
                        cedarObj = madrigal.cedar.MadrigalCedarFile(fullHdf5Filename)
                        cedarObj.write('netCDF4', fullFilename)
                
        # log access
        self.logDataAccess(fullHdf5Filename, user_fullname, user_email, user_affiliation)
        
        return(fullFilename)
    
    
    def downloadMultipleFiles(self, fileList, format, user_fullname, user_email, user_affiliation):
        """downloadMultipleFiles downloads multiple files in tarred format
        
        Returns a path to a Madrigal tarred file to download in given format as is (that is, with parms in file, and no filters)
        
        Inputs:
            fileList - list of full paths to Madrigal Hdf5 files
            format - 'hdf5', 'netCDF4', or 'ascii'
            user_fullname, user_email, user_affiliation - user identification strings
        """
        self.cleanStage()
        if format not in ('hdf5', 'netCDF4', 'ascii'):
            raise ValueError('Illegal format %s' % (str(format)))
        # create tmp dir if needed
        tmpDir = os.path.join(self._madDB.getMadroot(), 'experiments/stage')
        try:
            os.mkdir(tmpDir)
        except:
            pass
        # be sure no duplicate file names
        basenameList = []
        if format == 'hdf5':
            finalFileList = []
            for thisFile in fileList:
                basename = os.path.basename(thisFile)
                dirname = os.path.dirname(thisFile)
                if basename in basenameList:
                    basename = self.modifyBasename(basename)
                    fullFilename = os.path.join(tmpDir, basename)
                    shutil.copy(thisFile, fullFilename)
                else:
                    fullFilename = os.path.join(dirname, basename)
                basenameList.append(basename)
                finalFileList.append(fullFilename)
                
        else:
            # dynamically create files
            if format == 'netCDF4':
                thisExt = '.nc'
            elif format == 'ascii':
                thisExt = '.txt'
            finalFileList = []
            for thisFile in fileList:
                if not os.access(thisFile, os.R_OK):
                    raise IOError('Unable to find Hdf5 file %s' % (str(thisFile)))
                base, file_extension = os.path.splitext(thisFile)
                basename = os.path.basename(base + thisExt)
                if basename in basenameList:
                    basename = self.modifyBasename(basename)
                basenameList.append(basename)
                fullFilename = os.path.join(tmpDir, basename)
                
                if format == 'ascii':
                    cachedFile = os.path.join(os.path.dirname(thisFile), 'overview', 
                                              os.path.basename(thisFile) + '.txt.gz')
                    if os.access(cachedFile, os.R_OK):
                        fullFilename += '.gz'
                        if not os.access(fullFilename, os.R_OK):
                            shutil.copy(cachedFile, fullFilename)
                    else:
                        madrigal.cedar.convertToText(thisFile, fullFilename)
                elif format == 'netCDF4':
                    cachedFile = os.path.join(os.path.dirname(thisFile), 'overview', 
                                              os.path.basename(thisFile) + '.nc')
                    if os.access(cachedFile, os.R_OK):
                        if not os.access(fullFilename, os.R_OK):
                            shutil.copy(cachedFile, fullFilename)
                    else:
                        try:
                            madrigal.cedar.convertToNetCDF4(thisFile, fullFilename)
                        except IOError:
                            cedarObj = madrigal.cedar.MadrigalCedarFile(thisFile)
                            cedarObj.write('netCDF4', fullFilename)
                finalFileList.append(fullFilename)
                
        # create tar file
        now = datetime.datetime.now()
        tar_filename = os.path.join(tmpDir, 'madrigalFiles_%s.tar' % (now.strftime('%Y%m%dT%H%M%S')))
        tar = tarfile.open(tar_filename, "w")
        for thisFile in finalFileList:
            # log access
            self.logDataAccess(thisFile, user_fullname, user_email, user_affiliation)
            tar.add(thisFile)
            # let clean stage do this - safer
        return(tar_filename)
        
    
    
    
    def printFileAsIs(self, fullFilename, user_fullname, user_email, user_affiliation, html=True):
        """printFileAsIs returns the full path to a temp file representing file as plain text or html to print as is (that is, with parms rom file, and no filters)
        
        Inputs:
            fullFilename - full path to Madrigal Hdf5 file to convert to string
            user_fullname, user_email, user_affiliation - user identification strings
            html - if True (the default) return as Html with popup parm names.  If False, pure text
        """
        self.cleanStage()
        
        # create tmp dir if needed
        tmpDir = os.path.join(self._madDB.getMadroot(), 'experiments/stage')
        try:
            os.mkdir(tmpDir)
        except:
            pass
        
        fileName, fileExtension = os.path.splitext(fullFilename)
        fullTmpFilename = os.path.join(tmpDir, os.path.basename(fileName + '.txt'))

        if os.access(fullTmpFilename, os.R_OK):
            try:
                os.remove(fullTmpFilename)
            except:
                pass
        if html:
            summary = 'html'
        else:
            summary = 'plain'
        madrigal.cedar.convertToText(fullFilename, fullTmpFilename, summary=summary)
                
        # log access
        self.logDataAccess(fullFilename, user_fullname, user_email, user_affiliation)
        
        return(fullTmpFilename)
    
    
    def listRecords(self, fullFilename):
        """listRecords returns the list records html for fullFilename
        """
        # check if record plots exist
        basename = os.path.basename(fullFilename)
        thisDir = os.path.dirname(fullFilename)
        pngFiles = glob.glob(os.path.join(thisDir, 'plots', basename, 'records/*.png'))
        if len(pngFiles) > 0:
            url = '<a href="javascript:plotRecno(%i)">View record plot</a>'
        else:
            url = None
        
        output = os.path.join(tempfile.gettempdir(), 'tmp_%i.txt' % (random.randint(0,999999)))
        
        madrigal.cedar.listRecords(fullFilename, output, url)
        
        f = open(output)
        text = f.read()
        f.close()
        os.remove(output)
        return(text.strip())
        
    
    
    def downloadIsprintFileFromIsprintForm(self, isprintForm, user_fullname, user_email, user_affiliation):
        """downloadIsprintFileFromIsprintForm returns a full path to the temp file is experiments/stage created by isprint to download.
        
        Inputs:
            isprintForm - the django form that encapsulates all information from get_advanced web page.  
            user_fullname, user_email, user_affiliation - user identification strings
        """
        # defaults arguments
        showHeaders=False
        missing=None
        assumed=None
        knownbad=None
        
        orgFilename = isprintForm['fullFilename']
        requestedParms = isprintForm['parameters']
        # make unique
        uniqueRequestedParms = []
        for s in requestedParms:
            if type(s) in (bytes, numpy.bytes_):
                s = s.decode("ascii")
            asciiParm = s.lower().strip()
            if asciiParm not in uniqueRequestedParms:
                uniqueRequestedParms.append(asciiParm)
        start_date = isprintForm['start_date']
        end_date = isprintForm['end_date']
        
        format = isprintForm['formats']
        # create name of temp file
        basename_noext, ext = os.path.splitext(os.path.basename(orgFilename))
        randint = random.randint(0,999999)
        if format in ('ascii', 'netCDF4'):
            # need new basename
            if format == 'ascii':
                basename = basename_noext + '_%06i.txt' % (randint)
            else:
                basename = basename_noext + '_%06i.nc' % (randint)
        else:
            basename = basename_noext + '_%06i.hdf5' % (randint)
        tmpFile = os.path.join(self._madDB.getMadroot(), 'experiments/stage', basename)
        
        if format == 'ascii':
            # reset defaults
            showHeaders = isprintForm['showHeaders']
            missing = isprintForm['missing']
            assumed = isprintForm['missing']
            knownbad = isprintForm['missing']
            
        # next task - create a list of filters, but only if actually modified
        madFilters = []
        
        madFileObj = madrigal.data.MadrigalFile(orgFilename, self._madDB) # used to determine default values
        
        # check if we need a time filer
        earliestTime = madFileObj.getEarliestTime()
        latestTime = madFileObj.getLatestTime()
        earliestDT = datetime.datetime(*earliestTime)
        latestDT = datetime.datetime(*latestTime)
        earliest_unix = calendar.timegm(earliestDT.timetuple())
        latest_unix = calendar.timegm(latestDT.timetuple())
        start_unix = calendar.timegm(start_date.timetuple())
        end_unix = calendar.timegm(end_date.timetuple())
        
        if earliest_unix < start_unix or latest_unix > end_unix:
            # we need a time filter
            madFilters.append(madrigal.derivation.MadrigalFilter('ut1_unix', [(start_unix, end_unix)]))
            
        # altitude filter
        if 'min_alt' in isprintForm:
            file_min_alt = madFileObj.getMinValidAltitude()
            file_max_alt = madFileObj.getMaxValidAltitude()
            try:
                min_alt = float(isprintForm['min_alt'])
            except ValueError:
                min_alt = float('nan')
            try:
                max_alt = float(isprintForm['max_alt'])
            except ValueError:
                max_alt = float('nan')
            is_needed = False
            if not math.isnan(min_alt):
                if min_alt > file_min_alt + 1.0E-6:
                    is_needed = True
            if not math.isnan(max_alt):
                if max_alt < file_max_alt - 1.0E-6:
                    is_needed = True
            if is_needed:
                madFilters.append(madrigal.derivation.MadrigalFilter('gdalt', [(min_alt, max_alt)]))
                
        # azimuth filter
        if 'min_az' in isprintForm:
            try:
                min_az = float(isprintForm['min_az'])
            except ValueError:
                min_az = float('nan')
            try:
                max_az = float(isprintForm['max_az'])
            except ValueError:
                max_az = float('nan')
            try:
                min_az2 = float(isprintForm['min_az2'])
            except ValueError:
                min_az2 = float('nan')
            try:
                max_az2 = float(isprintForm['max_az2'])
            except ValueError:
                max_az2 = float('nan')
            is_needed = False
            if not math.isnan(min_az):
                if min_az > -180.0:
                    is_needed = True
            if not math.isnan(max_az):
                if max_az < 180.0:
                    is_needed = True
            if is_needed:
                madFilters.append(madrigal.derivation.MadrigalFilter('azm', [(min_az, max_az), (min_az2, max_az2)]))
                
        # elevation filter
        if 'min_el' in isprintForm:
            try:
                min_el = float(isprintForm['min_el'])
            except ValueError:
                min_el = float('nan')
            try:
                max_el = float(isprintForm['max_el'])
            except ValueError:
                max_el = float('nan')
            try:
                min_el2 = float(isprintForm['min_el2'])
            except ValueError:
                min_el2 = float('nan')
            try:
                max_el2 = float(isprintForm['max_el2'])
            except ValueError:
                max_el2 = float('nan')
            is_needed = False
            if not math.isnan(min_el):
                if min_el > 0.0:
                    is_needed = True
            if not math.isnan(max_el):
                if max_el < 90.0:
                    is_needed = True
            if is_needed:
                madFilters.append(madrigal.derivation.MadrigalFilter('azm', [(min_el, max_el), (min_el2, max_el2)]))  
            
        # pulse length filter
        if 'min_pl' in isprintForm:
            file_min_pl = madFileObj.getMinPulseLength()
            file_max_pl = madFileObj.getMaxPulseLength()
            try:
                min_pl = float(isprintForm['min_pl'])
            except ValueError:
                min_pl = float('nan')
            try:
                max_pl = float(isprintForm['max_pl'])
            except ValueError:
                max_pl = float('nan')
            is_needed = False
            if not math.isnan(min_pl):
                if min_pl > file_min_pl + 1.0E-9:
                    is_needed = True
            if not math.isnan(max_pl):
                if max_pl < file_max_pl - 1.0E-9:
                    is_needed = True
            if is_needed:
                madFilters.append(madrigal.derivation.MadrigalFilter('pl', [(min_pl, max_pl)]))
        
        # free parameters
        for i in range(1, 4):
            parm_name = isprintForm['parm_%i' % (i)]
            parm_lower = isprintForm['parm_%i_lower' % (i)]
            parm_upper = isprintForm['parm_%i_upper' % (i)]
            if parm_name == 'None':
                continue
            if len(parm_lower) == 0 and len(parm_upper) == 0:
                continue
            # filter needed
            try:
                min_value = float(parm_lower)
            except ValueError:
                min_value = float('nan')
            try:
                max_value = float(parm_upper)
            except ValueError:
                max_value = float('nan')
            madFilters.append(madrigal.derivation.MadrigalFilter(parm_name, [(min_value, max_value)]))
            
        # create new temp file
        madrigal.isprint.Isprint(orgFilename, tmpFile, uniqueRequestedParms, madFilters,
                                 showHeaders=showHeaders, missing=missing, assumed=assumed, knownbad=knownbad)
        
        # log access
        self.logDataAccess(orgFilename, user_fullname, user_email, user_affiliation)
        
        return(tmpFile)
    
    
    def runMadrigalCalculatorFromForm(self, madCalculatorForm):
        """runMadrigalCalculatorFromForm returns the text output of madCalculator from the MadCalulatorForm
        
        Inputs:
            madCalculatorForm - the django form that encapsulates all information from madrigal_calculator web page.  
        """
        requestedParms = madCalculatorForm['parameters']
        requestedParms = ['gdlat', 'glon', 'gdalt'] + [str(parm) for parm in requestedParms]
        thisDT = madCalculatorForm['datetime']
        
        min_latitude = madCalculatorForm['min_latitude']
        max_latitude = madCalculatorForm['max_latitude']
        delta_latitude = madCalculatorForm['delta_latitude']
        
        min_longitude = madCalculatorForm['min_longitude']
        max_longitude = madCalculatorForm['max_longitude']
        delta_longitude = madCalculatorForm['delta_longitude']
        
        min_altitude = madCalculatorForm['min_altitude']
        max_altitude = madCalculatorForm['max_altitude']
        delta_altitude = madCalculatorForm['delta_altitude']
        
        latList = numpy.arange(min_latitude, max_latitude+0.001*delta_latitude, delta_latitude).tolist()
        lonList = numpy.arange(min_longitude, max_longitude+0.001*delta_longitude, delta_longitude).tolist()
        altList = numpy.arange(min_altitude, max_altitude+0.001*delta_altitude, delta_altitude).tolist()
        
        if 0 in (len(latList), len(lonList), len(altList)):
            raise ValueError('Got 0 length spatial range')
        
        output = os.path.join(tempfile.gettempdir(), 'tmp_%i.txt' % (random.randint(0,999999)))
        
        madrigal.isprint.MadCalculatorGrid(output, requestedParms, [thisDT], latList, lonList, altList)
        
        f = open(output)
        text = f.read()
        f.close()
        os.remove(output)
        return(text.strip())
    
    
    def runLookerFromForm(self, form):
        """runLookerFromForm returns the text output of looker from one of the looker forms
        
        Inputs:
            form - the django form that encapsulates all information from looker web page.  
        """
        looker_cmd = os.path.join(self._madDB.getMadroot(), 'bin/looker1')
        looker_options = int(form['looker_options'])
        if looker_options in (1,2):
            try:
                kinst = int(form['instruments'])
                if kinst == 0:
                    raise ValueError('')
                slatgd = self._instObj.getLatitude(kinst)
                slon = self._instObj.getLongitude(kinst)
                if slon > 180.0:
                    slon -= 360.0
                saltgd = self._instObj.getAltitude(kinst)
            except:
                slatgd = float(form['inst_lat'])
                slon = float(form['inst_lon'])
                saltgd = float(form['inst_alt'])
            try:
                year = float(form['year'])
            except:
                year = 2000.0
            argStr = ' %i ' + '%f ' * 13
            argStr = argStr % (looker_options, year, slatgd, slon, saltgd,
                               float(form['start_lat']), float(form['stop_lat']), float(form['step_lat']),
                               float(form['start_lon']), float(form['stop_lon']), float(form['step_lon']),
                               float(form['start_alt']), float(form['stop_alt']), float(form['step_alt']))
            looker_cmd += argStr
            try:
                text = subprocess.check_output(looker_cmd.split())
            except:
                raise IOError('Unable to run cmd <%s>' % (looker_cmd))
            if type(text) == bytes:
                text = text.decode('utf-8')
            return(text)
        
        elif looker_options in (3,):
            try:
                year = float(form['year'])
            except:
                year = 2000.0
            argStr = ' %i ' + '%f ' * 13
            argStr = argStr % (looker_options, year, 0.0, 0.0, 0.0,
                               float(form['start_lat']), float(form['stop_lat']), float(form['step_lat']),
                               float(form['start_lon']), float(form['stop_lon']), float(form['step_lon']),
                               float(form['start_alt']), float(form['stop_alt']), float(form['step_alt']))
            looker_cmd += argStr
            text = subprocess.check_output(looker_cmd.split())
            if type(text) == bytes:
                text = text.decode('utf-8')
            return(text)
        elif looker_options in (4,):
            try:
                kinst = int(form['instruments'])
                if kinst == 0:
                    raise ValueError('')
                slatgd = self._instObj.getLatitude(kinst)
                slon = self._instObj.getLongitude(kinst)
                if slon > 180.0:
                    slon -= 360.0
                saltgd = self._instObj.getAltitude(kinst)
            except:
                slatgd = float(form['inst_lat'])
                slon = float(form['inst_lon'])
                saltgd = float(form['inst_alt'])
            try:
                year = float(form['year'])
            except:
                year = 2000.0
            argStr = ' %i ' + '%f ' * 13
            argStr = argStr % (looker_options, year, slatgd, slon, saltgd,
                               float(form['start_az']), float(form['stop_az']), float(form['step_az']),
                               float(form['start_el']), float(form['stop_el']), float(form['step_el']),
                               float(form['start_range']), float(form['stop_range']), float(form['step_range']))
            looker_cmd += argStr
            text = subprocess.check_output(looker_cmd.split())
            if type(text) == bytes:
                text = text.decode('utf-8')
            return(text)
        elif looker_options in (5,6,7):
            try:
                kinst = int(form['instruments'])
                if kinst == 0:
                    raise ValueError('')
                slatgd = self._instObj.getLatitude(kinst)
                slon = self._instObj.getLongitude(kinst)
                if slon > 180.0:
                    slon -= 360.0
                saltgd = self._instObj.getAltitude(kinst)
            except:
                slatgd = float(form['inst_lat'])
                slon = float(form['inst_lon'])
                saltgd = float(form['inst_alt'])
            try:
                year = float(form['year'])
            except:
                year = 2000.0
            argStr = ' %i ' + '%f ' * 13
            if looker_options == 5:
                p1 = float(form['fl_az'])
                p2 = float(form['fl_el'])
                p3 = float(form['fl_range'])
            elif looker_options == 6:
                p1 = float(form['fl_lat'])
                p2 = float(form['fl_lon'])
                p3 = float(form['fl_alt'])
            elif looker_options == 7:
                p1 = float(form['fl_apex_lat'])
                p2 = float(form['fl_apex_lon'])
                p3 = 0.0
            argStr = argStr % (looker_options, year, slatgd, slon, saltgd,
                               p1, p2, p3,
                               float(form['start_alt']), float(form['stop_alt']), float(form['step_alt']),
                               0.0, 0.0, 0.0)
            looker_cmd += argStr
            text = subprocess.check_output(looker_cmd.split())
            if type(text) == bytes:
                text = text.decode('utf-8')
            return(text)
        elif looker_options in (8,):
            latList = numpy.arange(float(form['start_lat']), float(form['stop_lat']), float(form['step_lat']))
            latList = latList.tolist()
            # check for null list
            if len(latList) == 0 and abs(float(form['start_lat']) - float(form['stop_lat'])) < 1.0E-6:
                latList = [float(form['start_lat'])]
            lonList = numpy.arange(float(form['start_lon']), float(form['stop_lon']), float(form['step_lon']))
            lonList = lonList.tolist()
            # check for null list
            if len(lonList) == 0 and abs(float(form['start_lon']) - float(form['stop_lon'])) < 1.0E-6:
                lonList = [float(form['start_lon'])]
            altList = numpy.arange(float(form['start_alt']), float(form['stop_alt']), float(form['step_alt']))
            altList = altList.tolist()
            # check for null list
            if len(altList) == 0 and abs(float(form['start_alt']) - float(form['stop_alt'])) < 1.0E-6:
                altList = [float(form['start_alt'])]
            requestedParms = ['gdlat', 'glon', 'gdalt'] + [str(parm.lower()) for parm in form['pList']]
            dtList = [form['datetime']]
            output = os.path.join(tempfile.gettempdir(), 'tmp_%i.txt' % (random.randint(0,999999)))

            madrigal.isprint.MadCalculatorGrid(output, requestedParms, dtList, latList, lonList, altList)
            f = open(output)
            text = f.read()
            f.close()
            os.remove(output)
            if type(text) == bytes:
                text = text.decode('utf-8')
            return(text.strip())
            
        else:
            raise ValueError('Unknown looker_options %s' % (str(looker_options)))
        
            
        
        
    def cleanStage(self):
        """cleanStage removes all temp files more than 2 hours old from experiments/stage
        """
        stageDir = os.path.join(self._madDB.getMadroot(), 'experiments/stage')
        filesToTest = glob.glob(os.path.join(stageDir, '*'))
        now = datetime.datetime.now()
        cutoff = datetime.timedelta(hours=2)
        for fileToTest in filesToTest:
            try:
                mDT = datetime.datetime.fromtimestamp(os.path.getmtime(fileToTest))
            except:
                continue
            if now - mDT > cutoff:
                try:
                    os.remove(fileToTest)
                except:
                    pass # ignore problems
                
                
    def modifyBasename(self, basename):
        """modifyBasename adds _<num> to make sure basename unique
        """
        base, file_extension = os.path.splitext(basename)
        index = base.rfind('_')
        if index != -1:
            try:
                length = len(base[index+1:])
                version = int(base[index+1:])
                # in case of overflow
                length = max(length, len(str(version + 1)))
                format = '%%0%ii' % (length)
                return('%s_%s%s' % (base[:index], format % (version + 1), file_extension))
            except:
                pass
        return('%s_%i%s' % (base, 1, file_extension))
            
            
        
            
            
    def _getDaynoFilter(self, seasonalStartDate, seasonalEndDate):
        """_getDaynoFilter returns a filter str in the form dayno,<lower>,<upper>
        
        Inputs:
            seasonalStartDate - a string in form 'MM/DD'.  Assumes non-leap year.
                Empty string means no filtering by seasonal start date.
            seasonalStartDate - a string in form 'MM/DD'.  Assumes non-leap year.
                Empty string means no filtering by seasonal end date.
        """
        startDayno = ''
        endDayno = ''
        if len(seasonalStartDate):
            startItems = seasonalStartDate.split('/')
            startDT = datetime.datetime(1958, int(startItems[0]),  int(startItems[1]))
            startDayno = int(startDT.strftime('%j'))
        if len(seasonalEndDate):
            endItems = seasonalEndDate.split('/')
            endDT = datetime.datetime(1958, int(endItems[0]),  int(endItems[1]))
            endDayno = int(endDT.strftime('%j'))
        return('dayno,%i,%i' % (startDayno, endDayno))


    def _getLock(self, filename):
        """_getLock is a private helper function that provides exclusive access to filename via a locking file.

        Inputs: filename = the file that exclusive access is required to.
        
        Returns: None

        Affects: Writes file filename + .LCK as a lock mechanism

        Exceptions: MadrigalError thrown if unable to write lock file

        Notes: Will sleep for 1 second at a time, for a maximum of _MaxSleep seconds (presently 10)
        if the file is not modified. After each second, it will check for the lock file to be removed
        or modified. If it was modified, it resets the count to 0 sec and starts counting again. After
        _MaxSleep counts it then assumes lock file is orphaned and returns.  Orphaned file will be
        removed when dropLock is called.
        """
        gotLock = 0
        numTries = 0
        modificationTime = 0
        
        while (not gotLock):

            try:
                file = os.open(filename + '.LCK', os.O_RDWR | os.O_CREAT | os.O_EXCL)
                os.close(file)
                gotLock = 1

            except OSError:
                # error 17 is "File exists"
                #(errno, strerror) = xxx_todo_changeme.args
                # error 17 is "File exists"
                #if errno != 17:
                    #raise madrigal.admin.MadrigalError("Unable to open " + filename + ".LCK as locking file ", None)
                # get modification time - may throw an error if file has disappearred
                try:
                    newModTime = (os.stat(filename + '.LCK')).st_mtime
                except:
                    #file has disappeared, no need to sleep
                    continue

                # if the lock file has been modified (or if this is the first time through) set numTries = 0
                if newModTime > modificationTime:
                    modificationTime = newModTime
                    numTries = 0
                    
                time.sleep(1)
                
            numTries = numTries + 1

            if numTries > self._MaxSleep:
                return

       
    def _dropLock(self, filename):
        """_dropLock is a private helper function that drops exclusive access to filename via a locking file.

        Inputs: filename = the file that exclusive access is required to.
        
        Returns: None

        Affects: Removes file filename + .LCK as a lock mechanism

        Exceptions: None.
        """
        try:
            os.remove(filename + '.LCK')

        except IOError:
            return
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#madrigal.ui.web.MadrigalWeb">MadrigalWeb</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, madDB=None)</p>
    </div>
    

    
  
    <div class="desc"><p><strong>init</strong> initializes MadrigalWeb by reading from MadridalDB..</p>
<p>Inputs: Existing MadrigalDB object, by default = None.</p>
<p>Returns: void</p>
<p>Affects: Initializes self._metaDir, self._logFile.</p>
<p>Exceptions: None.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.__init__', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.__init__" class="source">
    <pre><code>def __init__(self, madDB = None):
    """__init__ initializes MadrigalWeb by reading from MadridalDB..
    Inputs: Existing MadrigalDB object, by default = None.
    
    Returns: void
    Affects: Initializes self._metaDir, self._logFile.
    Exceptions: None.
    """
    if madDB == None:
        self._madDB = madrigal.metadata.MadrigalDB()
    else:
        self._madDB = madDB
    self._binDir = self._madDB.getBinDir()
    self._instObj = madrigal.metadata.MadrigalInstrument(self._madDB)
    self._madKindatObj = madrigal.metadata.MadrigalKindat(self._madDB)
    metaDir = self._madDB.getMetadataDir()
    # get todays year
    now = datetime.datetime.now()
    thisYear = '%04i' % (now.year)
    self._logFile = os.path.join(metaDir, 'userdata', 'access_%s.log' % (thisYear))
    # be sure it exists
    if not os.access(self._logFile, os.R_OK):
        f=open(self._logFile, 'w')
        f.close()
    # keep track of whether user trusted
    self._isTrusted_ = None
    
    # cache Madrigal objects as needed to imprive performance
    self._madExpObjExpID = None # will be set to a MadrigalExperiment object sorted by expId when first needed
    self._madExpObjDate = None # will be set to a MadrigalExperiment object sorted by date when first needed
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.cleanStage">
    <p>def <span class="ident">cleanStage</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>cleanStage removes all temp files more than 2 hours old from experiments/stage</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.cleanStage', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.cleanStage" class="source">
    <pre><code>def cleanStage(self):
    """cleanStage removes all temp files more than 2 hours old from experiments/stage
    """
    stageDir = os.path.join(self._madDB.getMadroot(), 'experiments/stage')
    filesToTest = glob.glob(os.path.join(stageDir, '*'))
    now = datetime.datetime.now()
    cutoff = datetime.timedelta(hours=2)
    for fileToTest in filesToTest:
        try:
            mDT = datetime.datetime.fromtimestamp(os.path.getmtime(fileToTest))
        except:
            continue
        if now - mDT > cutoff:
            try:
                os.remove(fileToTest)
            except:
                pass # ignore problems
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.createGlobalDownloadCmd">
    <p>def <span class="ident">createGlobalDownloadCmd</span>(</p><p>self, language, madrigalUrl, output, format, user_fullname, user_email, user_affiliation, start_datetime, end_datetime, instCode, kindatList, expName, fileDesc)</p>
    </div>
    

    
  
    <div class="desc"><p>createGlobalDownloadCmd returns a string representing a global download as is command to run in a particular language.</p>
<p>Inputs:</p>
<pre><code>language - which language to use.  Allowed values are ('python', 'Matlab', 'IDL')
madrigalUrl - url to madrigal home page where data is
output - output directory name
format - 'hdf5', 'ascii', or 'netCDF4'
user_fullname
user_email
user_affiliation
start_datetime - a datetime object. Reject experiments before that datetime
end_datetime - a datetime object. Reject experiments after that datetime
instCode - instrument code (integer)
kindatList - a list of kindat codes.  An empty list selects all kindats
expName - filter experiments by the experiment name. Matching is case insensitive and fnmatch characters * and ? are allowed. 
    Empty string is no filtering by experiment name.
fileDesc - filter files by the file description string. Matching is case insensitive and fnmatch characters * and ? are allowed. 
    Empty string is no filtering by file description.
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.createGlobalDownloadCmd', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.createGlobalDownloadCmd" class="source">
    <pre><code>def createGlobalDownloadCmd(self, language, madrigalUrl, output, format,
                           user_fullname, user_email, user_affiliation,
                           start_datetime, end_datetime, instCode,
                           kindatList, expName, fileDesc):
    """createGlobalDownloadCmd returns a string representing a global download as is command to run in a particular language.
    
    Inputs:
    
        language - which language to use.  Allowed values are ('python', 'Matlab', 'IDL')
        madrigalUrl - url to madrigal home page where data is
        output - output directory name
        format - 'hdf5', 'ascii', or 'netCDF4'
        user_fullname
        user_email
        user_affiliation
        start_datetime - a datetime object. Reject experiments before that datetime
        end_datetime - a datetime object. Reject experiments after that datetime
        instCode - instrument code (integer)
        kindatList - a list of kindat codes.  An empty list selects all kindats
        expName - filter experiments by the experiment name. Matching is case insensitive and fnmatch characters * and ? are allowed. 
            Empty string is no filtering by experiment name.
        fileDesc - filter files by the file description string. Matching is case insensitive and fnmatch characters * and ? are allowed. 
            Empty string is no filtering by file description.
    """
    if language not in ('python', 'Matlab', 'IDL'):
        raise ValueError('language %s not supported' % (str(language)))
    
    # url
    if language == 'python':
        cmd = 'globalDownload.py --verbose --url=%s ' % (madrigalUrl)
    elif language == 'Matlab':
        cmd = "globalDownload('%s', ...\n " % (madrigalUrl)
    elif language == 'IDL':
        cmd = "madglobaldownload, '%s',  $\n " % (madrigalUrl)
        
    # output
    if language == 'python':
        cmd += '--outputDir=%s ' % (output)
    elif language == 'Matlab':
        cmd += "'%s', ...\n " % (output)
    elif language == 'IDL':
        cmd += "'%s',  $\n " % (output)
        
    # user_fullname
    if language == 'python':
        cmd += '--user_fullname="%s" ' % (user_fullname)
    elif language == 'Matlab':
        cmd += "'%s', ...\n " % (user_fullname)
    elif language == 'IDL':
        cmd += "'%s',  $\n " % (user_fullname)
        
    # user_email
    if language == 'python':
        cmd += '--user_email=%s ' % (user_email)
    elif language == 'Matlab':
        cmd += "'%s', ...\n " % (user_email)
    elif language == 'IDL':
        cmd += "'%s',  $\n " % (user_email)
        
    # user_affiliation
    if language == 'python':
        cmd += '--user_affiliation="%s" ' % (user_affiliation)
    elif language == 'Matlab':
        cmd += "'%s', ...\n " % (user_affiliation)
    elif language == 'IDL':
        cmd += "'%s',  $\n " % (user_affiliation)
        
    # format part 1 (format is not in same order in Matlab and IDL)
    if format not in ('hdf5', 'ascii', 'netCDF4'):
        raise ValueError('format not in hdf5, ascii or netCDF4')
    if language == 'python':
        cmd += '--format="%s" ' % (format)
    elif language == 'Matlab':
        cmd += "'%s', ...\n " % (format)
    
    # start_datetime
    if language == 'python':
        cmd += '--startDate="%s" ' % (start_datetime.strftime('%m/%d/%Y'))
    elif language == 'Matlab':
        cmd += "datenum('%s'), ...\n " % (start_datetime.strftime('%d-%b-%Y %H:%M:%S'))
    elif language == 'IDL':
        cmd += "julday(%i,%i,%i,%i,%i,%i),  $\n " % (start_datetime.month, start_datetime.day,
                                                      start_datetime.year, start_datetime.hour,
                                                      start_datetime.minute, start_datetime.second)
        
    # end_datetime
    if language == 'python':
        cmd += '--endDate="%s" ' % (end_datetime.strftime('%m/%d/%Y'))
    elif language == 'Matlab':
        cmd += "datenum('%s'), ...\n " % (end_datetime.strftime('%d-%b-%Y %H:%M:%S'))
    elif language == 'IDL':
        cmd += "julday(%i,%i,%i,%i,%i,%i),  $\n " % (end_datetime.month, end_datetime.day,
                                                      end_datetime.year, end_datetime.hour,
                                                      end_datetime.minute, end_datetime.second)
        
    # instrument
    if language == 'python':
        cmd += '--inst=%i ' % (instCode)
    elif language == 'Matlab':
        cmd += "%i, ...\n " % (instCode)
    elif language == 'IDL':
        cmd += "%i,  $\n " % (instCode)
        
        
    # kindatList
    if language == 'python':
        if len(kindatList) == 0:
            pass
        else:
            kindatStr = '--kindat='
            for kindat in kindatList:
                kindatStr += '%i' % (kindat)
                if kindat != kindatList[-1]:
                    kindatStr += ','
            cmd += '%s ' % (kindatStr)
    elif language == 'Matlab':
        kindatStr = '['
        for kindat in kindatList:
            if kindat == 0:
                continue
            kindatStr += '%i' % (kindat)
            if kindat != kindatList[-1]:
                kindatStr += ','
        kindatStr += ']'
        cmd += "%s, ...\n " % (kindatStr)
    elif language == 'IDL':
        # make sure 0 not in list
        try:
            kindatList.remove(0)
        except ValueError:
            pass
        if len(kindatList) == 0:
            kindatStr = 'PTR_NEW()'
        else:
            kindatStr = '['
            for kindat in kindatList:
                kindatStr += '%i' % (kindat)
                if kindat != kindatList[-1]:
                    kindatStr += ','
            kindatStr += ']'
        cmd += "%s,  $\n " % (kindatStr)
        
        
    # now deal with IDL format if needed
    if language == 'IDL':
        cmd += "'%s',  $\n " % (format)
        
    # expName
    if language == 'python':
        if len(expName) > 0:
            cmd += '--expName="%s" ' % (expName)
    elif language == 'Matlab':
        expName = expName.replace('*', '.*')
        expName = expName.replace('?', '.?')
        cmd += "'%s', ...\n " % (expName)
    elif language == 'IDL':
        cmd += "'%s',  $\n " % (expName)
        
    # fileDesc
    if language == 'python':
        if len(fileDesc) > 0:
            cmd += '--fileDesc="%s" ' % (fileDesc)
    elif language == 'Matlab':
        fileDesc = fileDesc.replace('*', '.*')
        fileDesc = fileDesc.replace('?', '.?')
        cmd += "'%s') " % (fileDesc)
    elif language == 'IDL':
        cmd += "'%s' " % (fileDesc)
        
    return(cmd)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.createGlobalIsprintCmd">
    <p>def <span class="ident">createGlobalIsprintCmd</span>(</p><p>self, language, madrigalUrl, parmList, output, user_fullname, user_email, user_affiliation, start_datetime, end_datetime, instCode, filterList, kindatList, expName, fileDesc, seasonalStartDate, seasonalEndDate, format=None)</p>
    </div>
    

    
  
    <div class="desc"><p>createGlobalIsprintCmd returns a string representing a global isprint command to run in a particular language.</p>
<p>Inputs:</p>
<pre><code>language - which language to use.  Allowed values are ('python', 'Matlab', 'IDL')
madrigalUrl - url to madrigal home page where data is
parmList - ordered list of parameters requested.
output - output file name
user_fullname
user_email
user_affiliation
start_datetime - a datetime object. Reject experiments before that datetime
end_datetime - a datetime object. Reject experiments after that datetime
instCode - instrument code (integer)
filterList - a list of strings in form "mnem,lower,upper" where lower and/or upper may be empty
kindatList - a list of kindat codes.  An empty list selects all kindats
expName - filter experiments by the experiment name. Matching is case insensitive and fnmatch characters * and ? are allowed. 
    Empty string is no filtering by experiment name.
fileDesc - filter files by the file description string. Matching is case insensitive and fnmatch characters * and ? are allowed. 
    Empty string is no filtering by file description.
seasonalStartDate - a string in form 'MM/DD'.  Dates before then in any year will be ignored.  Assumes non-leap year.
    Empty string means no filtering by seasonal start date.
seasonalEndDate - a string in form 'MM/DD'.  Dates after then in any year will be ignored.  Assumes non-leap year.
    Empty string means no filtering by seasonal end date.
format - 'hdf5', 'ascii', or 'netCDF4'. If None, not specified (Madrigal 2 does not support this)
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.createGlobalIsprintCmd', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.createGlobalIsprintCmd" class="source">
    <pre><code>def createGlobalIsprintCmd(self, language, madrigalUrl, parmList, output,
                           user_fullname, user_email, user_affiliation,
                           start_datetime, end_datetime, instCode,
                           filterList, kindatList, expName, fileDesc,
                           seasonalStartDate, seasonalEndDate, format=None):
    """createGlobalIsprintCmd returns a string representing a global isprint command to run in a particular language.
    
    Inputs:
    
        language - which language to use.  Allowed values are ('python', 'Matlab', 'IDL')
        madrigalUrl - url to madrigal home page where data is
        parmList - ordered list of parameters requested.
        output - output file name
        user_fullname
        user_email
        user_affiliation
        start_datetime - a datetime object. Reject experiments before that datetime
        end_datetime - a datetime object. Reject experiments after that datetime
        instCode - instrument code (integer)
        filterList - a list of strings in form "mnem,lower,upper" where lower and/or upper may be empty
        kindatList - a list of kindat codes.  An empty list selects all kindats
        expName - filter experiments by the experiment name. Matching is case insensitive and fnmatch characters * and ? are allowed. 
            Empty string is no filtering by experiment name.
        fileDesc - filter files by the file description string. Matching is case insensitive and fnmatch characters * and ? are allowed. 
            Empty string is no filtering by file description.
        seasonalStartDate - a string in form 'MM/DD'.  Dates before then in any year will be ignored.  Assumes non-leap year.
            Empty string means no filtering by seasonal start date.
        seasonalEndDate - a string in form 'MM/DD'.  Dates after then in any year will be ignored.  Assumes non-leap year.
            Empty string means no filtering by seasonal end date.
        format - 'hdf5', 'ascii', or 'netCDF4'. If None, not specified (Madrigal 2 does not support this)
    """
    if language not in ('python', 'Matlab', 'IDL'):
        raise ValueError('language %s not supported' % (str(language)))
    
    # url
    if language == 'python':
        cmd = 'globalIsprint.py --verbose --url=%s ' % (madrigalUrl)
    elif language == 'Matlab':
        cmd = "globalIsprint('%s', ...\n " % (madrigalUrl)
    elif language == 'IDL':
        cmd = "madglobalprint, '%s',  $\n " % (madrigalUrl)
        
    # parms
    if len(parmList) == 0:
        raise ValueError('parmList cannot be empty')
    parmStr = ''
    for parm in parmList:
        parmStr += str(parm)
        if parm != parmList[-1]:
            parmStr += ','
    if language == 'python':
        cmd += '--parms=%s ' % (parmStr)
    elif language == 'Matlab':
        cmd += "'%s', ...\n " % (parmStr)
    elif language == 'IDL':
        cmd += "'%s',  $\n " % (parmStr)
        
    # output
    if language == 'python':
        cmd += '--output=%s ' % (output)
    elif language == 'Matlab':
        cmd += "'%s', ...\n " % (output)
    elif language == 'IDL':
        cmd += "'%s',  $\n " % (output)
        
    # user_fullname
    if language == 'python':
        cmd += '--user_fullname="%s" ' % (user_fullname)
    elif language == 'Matlab':
        cmd += "'%s', ...\n " % (user_fullname)
    elif language == 'IDL':
        cmd += "'%s',  $\n " % (user_fullname)
        
    # user_email
    if language == 'python':
        cmd += '--user_email=%s ' % (user_email)
    elif language == 'Matlab':
        cmd += "'%s', ...\n " % (user_email)
    elif language == 'IDL':
        cmd += "'%s',  $\n " % (user_email)
        
    # user_affiliation
    if language == 'python':
        cmd += '--user_affiliation="%s" ' % (user_affiliation)
    elif language == 'Matlab':
        cmd += "'%s', ...\n " % (user_affiliation)
    elif language == 'IDL':
        cmd += "'%s',  $\n " % (user_affiliation)
        
    
    # start_datetime
    if language == 'python':
        cmd += '--startDate="%s" ' % (start_datetime.strftime('%m/%d/%Y'))
    elif language == 'Matlab':
        cmd += "datenum('%s'), ...\n " % (start_datetime.strftime('%d-%b-%Y %H:%M:%S'))
    elif language == 'IDL':
        cmd += "julday(%i,%i,%i,%i,%i,%i),  $\n " % (start_datetime.month, start_datetime.day,
                                                      start_datetime.year, start_datetime.hour,
                                                      start_datetime.minute, start_datetime.second)
        
    # end_datetime
    if language == 'python':
        cmd += '--endDate="%s" ' % (end_datetime.strftime('%m/%d/%Y'))
    elif language == 'Matlab':
        cmd += "datenum('%s'), ...\n " % (end_datetime.strftime('%d-%b-%Y %H:%M:%S'))
    elif language == 'IDL':
        cmd += "julday(%i,%i,%i,%i,%i,%i),  $\n " % (end_datetime.month, end_datetime.day,
                                                      end_datetime.year, end_datetime.hour,
                                                      end_datetime.minute, end_datetime.second)
        
    # instrument
    if language == 'python':
        cmd += '--inst=%i ' % (instCode)
    elif language == 'Matlab':
        cmd += "%i, ...\n " % (instCode)
    elif language == 'IDL':
        cmd += "%i,  $\n " % (instCode)
        
    # format is here for Matlab or python
    if output == 'example.txt':
        format = None
    if language in ('Matlab', 'python'):
        if language == 'python':
            if not format is None:
                if format.lower() == 'hdf5':
                    cmd += '--format=%s ' % ('Hdf5')
                elif format in ('netCDF4', 'ascii'):
                    cmd += '--format=%s ' % (format)
        elif language == 'Matlab':
            if format is None:
                cmd += "'', ...\n "
            elif format.lower() == 'hdf5':
                cmd += "'%s', ...\n " % ('Hdf5')
            elif format in ('netCDF4', 'ascii'):
                cmd += "'%s', ...\n " % (format)
        
    # filterList
    # add seasonal filters if needed 
    if len(seasonalStartDate) or len(seasonalEndDate):
        daynoFilterStr = self._getDaynoFilter(seasonalStartDate, seasonalEndDate)
        filterList.append(daynoFilterStr)
    if language == 'python':
        for filterItem in filterList:
            cmd += '--filter=%s ' % (filterItem)
    elif language == 'Matlab':
        filterStr = ''
        for filterItem in filterList:
            filterStr += 'filter=%s ' % (filterItem)
        cmd += "'%s', ...\n " % (filterStr)
    elif language == 'IDL':
        filterStr = ''
        for filterItem in filterList:
            filterStr += 'filter=%s ' % (filterItem)
        cmd += "'%s',  $\n " % (filterStr)
        
    # kindatList
    if language == 'python':
        if len(kindatList) == 0:
            pass
        else:
            kindatStr = '--kindat='
            for kindat in kindatList:
                kindatStr += '%i' % (kindat)
                if kindat != kindatList[-1]:
                    kindatStr += ','
            cmd += '%s ' % (kindatStr)
    elif language == 'Matlab':
        kindatStr = '['
        for kindat in kindatList:
            if kindat == 0:
                continue
            kindatStr += '%i' % (kindat)
            if kindat != kindatList[-1]:
                kindatStr += ','
        kindatStr += ']'
        cmd += "%s, ...\n " % (kindatStr)
    elif language == 'IDL':
        # make sure 0 not in list
        try:
            kindatList.remove(0)
        except ValueError:
            pass
        if len(kindatList) == 0:
            kindatStr = 'PTR_NEW()'
        else:
            kindatStr = '['
            for kindat in kindatList:
                kindatStr += '%i' % (kindat)
                if kindat != kindatList[-1]:
                    kindatStr += ','
            kindatStr += ']'
        cmd += "%s,  $\n " % (kindatStr)
        
    # expName
    if language == 'python':
        if len(expName) > 0:
            cmd += '--expName="%s" ' % (expName)
    elif language == 'Matlab':
        expName = expName.replace('*', '.*')
        expName = expName.replace('?', '.?')
        cmd += "'%s', ...\n " % (expName)
    elif language == 'IDL':
        cmd += "'%s',  $\n " % (expName)
        
    # fileDesc
    if language == 'python':
        if len(fileDesc) > 0:
            cmd += '--fileDesc="%s" ' % (fileDesc)
    elif language == 'Matlab':
        fileDesc = fileDesc.replace('*', '.*')
        fileDesc = fileDesc.replace('?', '.?')
        cmd += "'%s') " % (fileDesc)
    elif language == 'IDL':
        cmd += "'%s',  $\n "  % (fileDesc)
        
    # format is here for idl
    if language == 'IDL':
        if format is None:
            cmd += "'',  $\n "
        elif format.lower() == 'hdf5':
            cmd += "'hdf5',  $\n "
        elif format in ('netCDF4', 'ascii'):
            cmd += "'%s',  $\n "  % (format)
        
        
        
    return(cmd)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.downloadFileAsIs">
    <p>def <span class="ident">downloadFileAsIs</span>(</p><p>self, expId, basename, user_fullname, user_email, user_affiliation)</p>
    </div>
    

    
  
    <div class="desc"><p>downloadFileAsIs returns a path to a Madrigal file to download as is (that is, with parms in file, and no filters)</p>
<p>Inputs:
    expId - experiment id of experiment
    basename - basename of file.  May have .txt or .nc extension, in which case Hdf5 file is converted
    user_fullname, user_email, user_affiliation - user identification strings</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.downloadFileAsIs', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.downloadFileAsIs" class="source">
    <pre><code>def downloadFileAsIs(self, expId, basename, user_fullname, user_email, user_affiliation):
    """downloadFileAsIs returns a path to a Madrigal file to download as is (that is, with parms in file, and no filters)
    
    Inputs:
        expId - experiment id of experiment
        basename - basename of file.  May have .txt or .nc extension, in which case Hdf5 file is converted
        user_fullname, user_email, user_affiliation - user identification strings
    """
    self.cleanStage()
    hdf5Extensions = ('.hdf5', '.h5', '.hdf')
    fileName, fileExtension = os.path.splitext(basename)
    if self._madExpObjExpID is None:
        self._madExpObjExpID = madrigal.metadata.MadrigalExperiment(self._madDB)
    expDir = self._madExpObjExpID.getExpDirByExpId(int(expId))
    if expDir is None:
        raise ValueError('No expDir found for exp_id %i' % (int(expId)))
    if fileExtension in hdf5Extensions:
        baseHdf5 = basename
    else:
        # we need to search for the hdf5 basename
        madFileObj = madrigal.metadata.MadrigalMetaFile(self._madDB, os.path.join(expDir, 'fileTab.txt'))
        baseHdf5 = None
        for i in range(madFileObj.getFileCount()):
            thisFileName, thisFileExt = os.path.splitext(madFileObj.getFilenameByPosition(i))
            if thisFileName == fileName and thisFileExt in hdf5Extensions:
                baseHdf5 = madFileObj.getFilenameByPosition(i)
                break
    if baseHdf5 is None:
        raise ValueError('No valid file for %s found in %s' % (basename, expDir))
    if basename == baseHdf5:
        fullFilename = os.path.join(expDir, basename)
        fullHdf5Filename = fullFilename
        tmpDir = None
    else:
        fullHdf5Filename = os.path.join(expDir, baseHdf5)
        # create tmp dir if needed
        tmpDir = os.path.join(self._madDB.getMadroot(), 'experiments/stage')
        try:
            os.mkdir(tmpDir)
        except:
            pass
        fullFilename = os.path.join(tmpDir, basename)
        if os.access(fullFilename, os.R_OK):
            try:
                os.remove(fullFilename)
            except:
                pass
        if fileExtension == '.txt':
            cachedFile = os.path.join(expDir, 'overview', baseHdf5 + '.txt.gz')
            if os.access(cachedFile, os.R_OK):
                fullFilename += '.gz'
                shutil.copy(cachedFile, fullFilename)
            else:
                madrigal.cedar.convertToText(fullHdf5Filename, fullFilename)
        elif fileExtension == '.nc':
            cachedFile = os.path.join(expDir, 'overview', baseHdf5 + '.nc')
            if os.access(cachedFile, os.R_OK):
                shutil.copy(cachedFile, fullFilename)
            else:
                try:
                    madrigal.cedar.convertToNetCDF4(fullHdf5Filename, fullFilename)
                except IOError:
                    cedarObj = madrigal.cedar.MadrigalCedarFile(fullHdf5Filename)
                    cedarObj.write('netCDF4', fullFilename)
            
    # log access
    self.logDataAccess(fullHdf5Filename, user_fullname, user_email, user_affiliation)
    
    return(fullFilename)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.downloadFullFileAsIs">
    <p>def <span class="ident">downloadFullFileAsIs</span>(</p><p>self, fullHdf5Filename, format, user_fullname, user_email, user_affiliation)</p>
    </div>
    

    
  
    <div class="desc"><p>downloadFullFileAsIs is similar to downloadFileAsIs with fullFilename input instead of expId .</p>
<p>Returns a path to a Madrigal file to download as is (that is, with parms in file, and no filters)</p>
<p>Inputs:
    fullHdf5Filename - full path to Madrigal Hdf5 file
    format - 'hdf5', 'netCDF4', or 'ascii'
    user_fullname, user_email, user_affiliation - user identification strings</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.downloadFullFileAsIs', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.downloadFullFileAsIs" class="source">
    <pre><code>def downloadFullFileAsIs(self, fullHdf5Filename, format, user_fullname, user_email, user_affiliation):
    """downloadFullFileAsIs is similar to downloadFileAsIs with fullFilename input instead of expId .
    
    Returns a path to a Madrigal file to download as is (that is, with parms in file, and no filters)
    
    Inputs:
        fullHdf5Filename - full path to Madrigal Hdf5 file
        format - 'hdf5', 'netCDF4', or 'ascii'
        user_fullname, user_email, user_affiliation - user identification strings
    """
    self.cleanStage()
    if format not in ('hdf5', 'netCDF4', 'ascii'):
        raise ValueError('Illegal format %s' % (str(format)))
    if not os.access(fullHdf5Filename, os.R_OK):
        raise IOError('Unable to find Hdf5 file %s' % (str(fullHdf5Filename)))
    if format == 'hdf5':
        fullFilename = fullHdf5Filename
        tmpDir = None
    else:
        # dynamically create file
        if format == 'netCDF4':
            thisExt = '.nc'
        elif format == 'ascii':
            thisExt = '.txt'
        # create tmp dir if needed
        tmpDir = os.path.join(self._madDB.getMadroot(), 'experiments/stage')
        try:
            os.mkdir(tmpDir)
        except:
            pass
        base, file_extension = os.path.splitext(fullHdf5Filename)
        basename = os.path.basename(base + thisExt)
        fullFilename = os.path.join(tmpDir, basename)
        if os.access(fullFilename, os.R_OK):
            try:
                os.remove(fullFilename)
            except:
                pass
        if format == 'ascii':
            cachedFile = os.path.join(os.path.dirname(fullHdf5Filename), 'overview', 
                                      os.path.basename(fullHdf5Filename) + '.txt.gz')
            if os.access(cachedFile, os.R_OK):
                fullFilename += '.gz'
                shutil.copy(cachedFile, fullFilename)
            else:
                madrigal.cedar.convertToText(fullHdf5Filename, fullFilename)
        elif format == 'netCDF4':
            cachedFile = os.path.join(os.path.dirname(fullHdf5Filename), 'overview', 
                                      os.path.basename(fullHdf5Filename) + '.nc')
            if os.access(cachedFile, os.R_OK):
                shutil.copy(cachedFile, fullFilename)
            else:
                try:
                    madrigal.cedar.convertToNetCDF4(fullHdf5Filename, fullFilename)
                except IOError:
                    cedarObj = madrigal.cedar.MadrigalCedarFile(fullHdf5Filename)
                    cedarObj.write('netCDF4', fullFilename)
            
    # log access
    self.logDataAccess(fullHdf5Filename, user_fullname, user_email, user_affiliation)
    
    return(fullFilename)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.downloadIsprintFileFromIsprintForm">
    <p>def <span class="ident">downloadIsprintFileFromIsprintForm</span>(</p><p>self, isprintForm, user_fullname, user_email, user_affiliation)</p>
    </div>
    

    
  
    <div class="desc"><p>downloadIsprintFileFromIsprintForm returns a full path to the temp file is experiments/stage created by isprint to download.</p>
<p>Inputs:
    isprintForm - the django form that encapsulates all information from get_advanced web page.<br />
    user_fullname, user_email, user_affiliation - user identification strings</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.downloadIsprintFileFromIsprintForm', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.downloadIsprintFileFromIsprintForm" class="source">
    <pre><code>def downloadIsprintFileFromIsprintForm(self, isprintForm, user_fullname, user_email, user_affiliation):
    """downloadIsprintFileFromIsprintForm returns a full path to the temp file is experiments/stage created by isprint to download.
    
    Inputs:
        isprintForm - the django form that encapsulates all information from get_advanced web page.  
        user_fullname, user_email, user_affiliation - user identification strings
    """
    # defaults arguments
    showHeaders=False
    missing=None
    assumed=None
    knownbad=None
    
    orgFilename = isprintForm['fullFilename']
    requestedParms = isprintForm['parameters']
    # make unique
    uniqueRequestedParms = []
    for s in requestedParms:
        if type(s) in (bytes, numpy.bytes_):
            s = s.decode("ascii")
        asciiParm = s.lower().strip()
        if asciiParm not in uniqueRequestedParms:
            uniqueRequestedParms.append(asciiParm)
    start_date = isprintForm['start_date']
    end_date = isprintForm['end_date']
    
    format = isprintForm['formats']
    # create name of temp file
    basename_noext, ext = os.path.splitext(os.path.basename(orgFilename))
    randint = random.randint(0,999999)
    if format in ('ascii', 'netCDF4'):
        # need new basename
        if format == 'ascii':
            basename = basename_noext + '_%06i.txt' % (randint)
        else:
            basename = basename_noext + '_%06i.nc' % (randint)
    else:
        basename = basename_noext + '_%06i.hdf5' % (randint)
    tmpFile = os.path.join(self._madDB.getMadroot(), 'experiments/stage', basename)
    
    if format == 'ascii':
        # reset defaults
        showHeaders = isprintForm['showHeaders']
        missing = isprintForm['missing']
        assumed = isprintForm['missing']
        knownbad = isprintForm['missing']
        
    # next task - create a list of filters, but only if actually modified
    madFilters = []
    
    madFileObj = madrigal.data.MadrigalFile(orgFilename, self._madDB) # used to determine default values
    
    # check if we need a time filer
    earliestTime = madFileObj.getEarliestTime()
    latestTime = madFileObj.getLatestTime()
    earliestDT = datetime.datetime(*earliestTime)
    latestDT = datetime.datetime(*latestTime)
    earliest_unix = calendar.timegm(earliestDT.timetuple())
    latest_unix = calendar.timegm(latestDT.timetuple())
    start_unix = calendar.timegm(start_date.timetuple())
    end_unix = calendar.timegm(end_date.timetuple())
    
    if earliest_unix < start_unix or latest_unix > end_unix:
        # we need a time filter
        madFilters.append(madrigal.derivation.MadrigalFilter('ut1_unix', [(start_unix, end_unix)]))
        
    # altitude filter
    if 'min_alt' in isprintForm:
        file_min_alt = madFileObj.getMinValidAltitude()
        file_max_alt = madFileObj.getMaxValidAltitude()
        try:
            min_alt = float(isprintForm['min_alt'])
        except ValueError:
            min_alt = float('nan')
        try:
            max_alt = float(isprintForm['max_alt'])
        except ValueError:
            max_alt = float('nan')
        is_needed = False
        if not math.isnan(min_alt):
            if min_alt > file_min_alt + 1.0E-6:
                is_needed = True
        if not math.isnan(max_alt):
            if max_alt < file_max_alt - 1.0E-6:
                is_needed = True
        if is_needed:
            madFilters.append(madrigal.derivation.MadrigalFilter('gdalt', [(min_alt, max_alt)]))
            
    # azimuth filter
    if 'min_az' in isprintForm:
        try:
            min_az = float(isprintForm['min_az'])
        except ValueError:
            min_az = float('nan')
        try:
            max_az = float(isprintForm['max_az'])
        except ValueError:
            max_az = float('nan')
        try:
            min_az2 = float(isprintForm['min_az2'])
        except ValueError:
            min_az2 = float('nan')
        try:
            max_az2 = float(isprintForm['max_az2'])
        except ValueError:
            max_az2 = float('nan')
        is_needed = False
        if not math.isnan(min_az):
            if min_az > -180.0:
                is_needed = True
        if not math.isnan(max_az):
            if max_az < 180.0:
                is_needed = True
        if is_needed:
            madFilters.append(madrigal.derivation.MadrigalFilter('azm', [(min_az, max_az), (min_az2, max_az2)]))
            
    # elevation filter
    if 'min_el' in isprintForm:
        try:
            min_el = float(isprintForm['min_el'])
        except ValueError:
            min_el = float('nan')
        try:
            max_el = float(isprintForm['max_el'])
        except ValueError:
            max_el = float('nan')
        try:
            min_el2 = float(isprintForm['min_el2'])
        except ValueError:
            min_el2 = float('nan')
        try:
            max_el2 = float(isprintForm['max_el2'])
        except ValueError:
            max_el2 = float('nan')
        is_needed = False
        if not math.isnan(min_el):
            if min_el > 0.0:
                is_needed = True
        if not math.isnan(max_el):
            if max_el < 90.0:
                is_needed = True
        if is_needed:
            madFilters.append(madrigal.derivation.MadrigalFilter('azm', [(min_el, max_el), (min_el2, max_el2)]))  
        
    # pulse length filter
    if 'min_pl' in isprintForm:
        file_min_pl = madFileObj.getMinPulseLength()
        file_max_pl = madFileObj.getMaxPulseLength()
        try:
            min_pl = float(isprintForm['min_pl'])
        except ValueError:
            min_pl = float('nan')
        try:
            max_pl = float(isprintForm['max_pl'])
        except ValueError:
            max_pl = float('nan')
        is_needed = False
        if not math.isnan(min_pl):
            if min_pl > file_min_pl + 1.0E-9:
                is_needed = True
        if not math.isnan(max_pl):
            if max_pl < file_max_pl - 1.0E-9:
                is_needed = True
        if is_needed:
            madFilters.append(madrigal.derivation.MadrigalFilter('pl', [(min_pl, max_pl)]))
    
    # free parameters
    for i in range(1, 4):
        parm_name = isprintForm['parm_%i' % (i)]
        parm_lower = isprintForm['parm_%i_lower' % (i)]
        parm_upper = isprintForm['parm_%i_upper' % (i)]
        if parm_name == 'None':
            continue
        if len(parm_lower) == 0 and len(parm_upper) == 0:
            continue
        # filter needed
        try:
            min_value = float(parm_lower)
        except ValueError:
            min_value = float('nan')
        try:
            max_value = float(parm_upper)
        except ValueError:
            max_value = float('nan')
        madFilters.append(madrigal.derivation.MadrigalFilter(parm_name, [(min_value, max_value)]))
        
    # create new temp file
    madrigal.isprint.Isprint(orgFilename, tmpFile, uniqueRequestedParms, madFilters,
                             showHeaders=showHeaders, missing=missing, assumed=assumed, knownbad=knownbad)
    
    # log access
    self.logDataAccess(orgFilename, user_fullname, user_email, user_affiliation)
    
    return(tmpFile)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.downloadMultipleFiles">
    <p>def <span class="ident">downloadMultipleFiles</span>(</p><p>self, fileList, format, user_fullname, user_email, user_affiliation)</p>
    </div>
    

    
  
    <div class="desc"><p>downloadMultipleFiles downloads multiple files in tarred format</p>
<p>Returns a path to a Madrigal tarred file to download in given format as is (that is, with parms in file, and no filters)</p>
<p>Inputs:
    fileList - list of full paths to Madrigal Hdf5 files
    format - 'hdf5', 'netCDF4', or 'ascii'
    user_fullname, user_email, user_affiliation - user identification strings</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.downloadMultipleFiles', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.downloadMultipleFiles" class="source">
    <pre><code>def downloadMultipleFiles(self, fileList, format, user_fullname, user_email, user_affiliation):
    """downloadMultipleFiles downloads multiple files in tarred format
    
    Returns a path to a Madrigal tarred file to download in given format as is (that is, with parms in file, and no filters)
    
    Inputs:
        fileList - list of full paths to Madrigal Hdf5 files
        format - 'hdf5', 'netCDF4', or 'ascii'
        user_fullname, user_email, user_affiliation - user identification strings
    """
    self.cleanStage()
    if format not in ('hdf5', 'netCDF4', 'ascii'):
        raise ValueError('Illegal format %s' % (str(format)))
    # create tmp dir if needed
    tmpDir = os.path.join(self._madDB.getMadroot(), 'experiments/stage')
    try:
        os.mkdir(tmpDir)
    except:
        pass
    # be sure no duplicate file names
    basenameList = []
    if format == 'hdf5':
        finalFileList = []
        for thisFile in fileList:
            basename = os.path.basename(thisFile)
            dirname = os.path.dirname(thisFile)
            if basename in basenameList:
                basename = self.modifyBasename(basename)
                fullFilename = os.path.join(tmpDir, basename)
                shutil.copy(thisFile, fullFilename)
            else:
                fullFilename = os.path.join(dirname, basename)
            basenameList.append(basename)
            finalFileList.append(fullFilename)
            
    else:
        # dynamically create files
        if format == 'netCDF4':
            thisExt = '.nc'
        elif format == 'ascii':
            thisExt = '.txt'
        finalFileList = []
        for thisFile in fileList:
            if not os.access(thisFile, os.R_OK):
                raise IOError('Unable to find Hdf5 file %s' % (str(thisFile)))
            base, file_extension = os.path.splitext(thisFile)
            basename = os.path.basename(base + thisExt)
            if basename in basenameList:
                basename = self.modifyBasename(basename)
            basenameList.append(basename)
            fullFilename = os.path.join(tmpDir, basename)
            
            if format == 'ascii':
                cachedFile = os.path.join(os.path.dirname(thisFile), 'overview', 
                                          os.path.basename(thisFile) + '.txt.gz')
                if os.access(cachedFile, os.R_OK):
                    fullFilename += '.gz'
                    if not os.access(fullFilename, os.R_OK):
                        shutil.copy(cachedFile, fullFilename)
                else:
                    madrigal.cedar.convertToText(thisFile, fullFilename)
            elif format == 'netCDF4':
                cachedFile = os.path.join(os.path.dirname(thisFile), 'overview', 
                                          os.path.basename(thisFile) + '.nc')
                if os.access(cachedFile, os.R_OK):
                    if not os.access(fullFilename, os.R_OK):
                        shutil.copy(cachedFile, fullFilename)
                else:
                    try:
                        madrigal.cedar.convertToNetCDF4(thisFile, fullFilename)
                    except IOError:
                        cedarObj = madrigal.cedar.MadrigalCedarFile(thisFile)
                        cedarObj.write('netCDF4', fullFilename)
            finalFileList.append(fullFilename)
            
    # create tar file
    now = datetime.datetime.now()
    tar_filename = os.path.join(tmpDir, 'madrigalFiles_%s.tar' % (now.strftime('%Y%m%dT%H%M%S')))
    tar = tarfile.open(tar_filename, "w")
    for thisFile in finalFileList:
        # log access
        self.logDataAccess(thisFile, user_fullname, user_email, user_affiliation)
        tar.add(thisFile)
        # let clean stage do this - safer
    return(tar_filename)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.filterLog">
    <p>def <span class="ident">filterLog</span>(</p><p>self, tmpFile, kinstList=None, accessStartDate=None, accessEndDate=None)</p>
    </div>
    

    
  
    <div class="desc"><p>filterLog writes a subsection of the access log to a temporary file</p>
<p>Inputs:</p>
<pre><code>tmpFile - temporary file to write subsection of log to

kinstList - list of kinsts to accept.  If None (the default), accept all instruments

accessStartDate - if not None (the default), reject all access dates before
    datetime accessStartDate

accessEndDate - if not None (the default), reject all access dates after
    datetime accessEndDate
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.filterLog', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.filterLog" class="source">
    <pre><code>def filterLog(self, tmpFile, kinstList=None, accessStartDate=None, accessEndDate=None):
    """filterLog writes a subsection of the access log to a temporary file
    
    Inputs:
    
        tmpFile - temporary file to write subsection of log to
        
        kinstList - list of kinsts to accept.  If None (the default), accept all instruments
        
        accessStartDate - if not None (the default), reject all access dates before
            datetime accessStartDate
            
        accessEndDate - if not None (the default), reject all access dates after
            datetime accessEndDate
        
    """
    f = open(tmpFile, 'w')
    
    accessLogs = glob.glob(os.path.join(self._madDB.getMadroot(), 'metadata/userdata/access_*.log'))
    accessLogs.sort()
    
    # addition for cedar only
    """accessLogs2 = glob.glob('/opt/cedar/metadata/userdata/access_*[0-9].log')
    accessLogs += accessLogs2
    accessLogs.sort()"""
    
    
    if kinstList:
        # create a dictionary of key = 3 letter inst mnem, value = kinstList
        instDict = {}
        instList = self._instObj.getInstrumentList()
        for inst in instList:
            if inst[1] in instDict:
                instDict[inst[1]].append(inst[2])
            else:
                instDict[inst[1]] = [inst[2]]
    
    for accessLog in accessLogs:
        # see if we can skip this year
        basename = os.path.basename(accessLog)
        year = int(basename[7:-4])
        startYear = datetime.datetime(year,1,1,0,0,0)
        endYear = datetime.datetime(year,12,31,23,59,59)
        if accessStartDate:
            if accessStartDate > endYear:
                continue
        if accessEndDate:
            if accessEndDate < startYear:
                continue
        # this file can be huge, so read one line at a time
        fl = open(accessLog)
        while True:
            line = fl.readline()
            if len(line) == 0:
                break
            items = line.strip().split(',')
            if len(items) != 5:
                continue
            # walk through filters
            
            # kinst
            if kinstList:
                # get the instrument mnemonic
                dirs = items[-1].split('/')
                found = False
                try:
                    for kinst in instDict[dirs[-3]]:
                        if kinst in kinstList:
                            found = True
                            break
                except KeyError:
                    continue
                if not found:
                    continue
                
            # access time
            if accessStartDate or accessEndDate:
                thisDT = datetime.datetime.strptime(items[-2], '%Y-%m-%d %H-%M-%S')
                if accessStartDate:
                    if accessStartDate > thisDT:
                        continue
                if accessEndDate:
                    if accessEndDate < thisDT:
                        continue
                    
            # all filters passed
            f.write(line)
            
        fl.close()
            
    f.close()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.generateDownloadFileScriptFromForm">
    <p>def <span class="ident">generateDownloadFileScriptFromForm</span>(</p><p>self, form, user_fullname, user_email, user_affiliation)</p>
    </div>
    

    
  
    <div class="desc"><p>generateDownloadFileScriptFromForm converts the Django form into arguments so that
if can then call createGlobalDownloadCmd.</p>
<p>form is a dict with keys:
    instruments, start_date, end_date, format_select, language_select, kindat_select,
    expName, fileDesc
user_fullname, user_email, user_affiliation - strings</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.generateDownloadFileScriptFromForm', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.generateDownloadFileScriptFromForm" class="source">
    <pre><code>def generateDownloadFileScriptFromForm(self, form, user_fullname,
                                       user_email, user_affiliation):
    """generateDownloadFileScriptFromForm converts the Django form into arguments so that
    if can then call createGlobalDownloadCmd.
    
    form is a dict with keys:
        instruments, start_date, end_date, format_select, language_select, kindat_select,
        expName, fileDesc
    user_fullname, user_email, user_affiliation - strings
        
    """
    instCode = int(form['instruments'])
    start_datetime = datetime.datetime(form['start_date'].year, form['start_date'].month, form['start_date'].day)
    end_datetime = datetime.datetime(form['end_date'].year, form['end_date'].month, form['end_date'].day)
    format = form['format_select']
    language = form['language_select']
    kindatList = [int(kindat) for kindat in form['kindat_select']]
    expName = form['expName'].strip()
    fileDesc = form['fileDesc'].strip()
    madrigalUrl = self._madDB.getTopLevelUrl()
    return(self.createGlobalDownloadCmd(language, madrigalUrl, '/tmp', format,
                           user_fullname, user_email, user_affiliation,
                           start_datetime, end_datetime, instCode,
                           kindatList, expName, fileDesc))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.generateGlobalIsprintScriptFromForm">
    <p>def <span class="ident">generateGlobalIsprintScriptFromForm</span>(</p><p>self, form1, form2, form3, user_fullname, user_email, user_affiliation)</p>
    </div>
    

    
  
    <div class="desc"><p>generateGlobalIsprintScriptFromForm converts the three Django forms into arguments so that
if can then call createGlobalIsprintCmd. Separate forms used because some parts are created by
Ajax.</p>
<p>form1 is a dict with keys:
    instruments, start_date, end_date, format_select, directory_select, language_select, kindat_select,
    expName, fileDesc, seasonalStartDay, seasonalStartMonth, seasonalEndDay, seasonalEndMonth
form2 is a dict with keys parameters
form3 is a dict with keys parm_#, parm_#<em>lower, parm</em>#_upper, where # is 1, 2, and 3
user_fullname, user_email, user_affiliation - strings</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.generateGlobalIsprintScriptFromForm', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.generateGlobalIsprintScriptFromForm" class="source">
    <pre><code>def generateGlobalIsprintScriptFromForm(self, form1, form2, form3, user_fullname,
                                        user_email, user_affiliation):
    """generateGlobalIsprintScriptFromForm converts the three Django forms into arguments so that
    if can then call createGlobalIsprintCmd. Separate forms used because some parts are created by
    Ajax.
    
    form1 is a dict with keys:
        instruments, start_date, end_date, format_select, directory_select, language_select, kindat_select,
        expName, fileDesc, seasonalStartDay, seasonalStartMonth, seasonalEndDay, seasonalEndMonth
    form2 is a dict with keys parameters
    form3 is a dict with keys parm_#, parm_#_lower, parm_#_upper, where # is 1, 2, and 3
    user_fullname, user_email, user_affiliation - strings
        
    """
    instCode = int(form1['instruments'])
    start_datetime = datetime.datetime(form1['start_date'].year, form1['start_date'].month, form1['start_date'].day)
    end_datetime = datetime.datetime(form1['end_date'].year, form1['end_date'].month, form1['end_date'].day)
    format = form1['format_select']
    if format == 'ascii' and form1['directory_select'] == 'File':
        output = 'example.txt'
    else:
        output = '/tmp'
    language = form1['language_select']
    kindatList = [int(kindat) for kindat in form1['kindat_select']]
    expName = form1['expName'].strip()
    fileDesc = form1['fileDesc'].strip()
    seasonalStartDay = int(form1['seasonalStartDay'])
    seasonalStartMonth = int(form1['seasonalStartMonth'])
    seasonalEndDay = int(form1['seasonalEndDay'])
    seasonalEndMonth = int(form1['seasonalEndMonth'])
    if seasonalStartDay == 1 and seasonalStartMonth == 1 and \
        seasonalEndDay == 31 and seasonalEndMonth == 12:
        seasonalStartDate = ''
        seasonalEndDate = ''
    else:
        seasonalStartDate = '%02i/%02i' % (seasonalStartMonth, seasonalStartDay)
        seasonalEndDate = '%02i/%02i' % (seasonalEndMonth, seasonalStartDay)
    madrigalUrl = self._madDB.getTopLevelUrl()
    parmList = form2['parameters']
    filterList = []
    for i in (1,2,3):
        try:
            parm = form3['parm_%i' % (i)]
        except KeyError:
            continue
        if len(parm) == 0:
            continue
        filterStr = '%s,' % (parm)
        try:
            parm_lower = form3['parm_%i_lower' % (i)]
            filterStr += '%s,' % (str(parm_lower))
        except KeyError:
            filterStr += ','
        try:
            parm_upper = form3['parm_%i_upper' % (i)]
            filterStr += '%s' % (str(parm_upper))
        except KeyError:
            pass
        filterList.append(filterStr)
        
        
    return(self.createGlobalIsprintCmd(language, madrigalUrl, parmList, output,
                                       user_fullname, user_email, user_affiliation,
                                       start_datetime, end_datetime, instCode,
                                       filterList, kindatList, expName, fileDesc,
                                       seasonalStartDate, seasonalEndDate, format))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.generateLogout">
    <p>def <span class="ident">generateLogout</span>(</p><p>self, fileName, expName)</p>
    </div>
    

    
  
    <div class="desc"><p>generateLogout generates a java script which sends a user to the madLogin page to logout automatically.</p>
<p>Inputs: fileName: the madrigal file to return to
        expName:  the experiment name of the file to return to</p>
<p>Returns: a java script which sends a user to the madLogin page to logout automatically</p>
<p>Affects: None.</p>
<p>Exceptions: None.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.generateLogout', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.generateLogout" class="source">
    <pre><code>def generateLogout(self, fileName, expName):
    """ generateLogout generates a java script which sends a user to the madLogin page to logout automatically.
    Inputs: fileName: the madrigal file to return to
            expName:  the experiment name of the file to return to
    
    Returns: a java script which sends a user to the madLogin page to logout automatically
    Affects: None.
    Exceptions: None.
    """
    print('<script language = "JavaScript">')
    print('\twindow.location = "madLogin?fileName=' + \
          fileName + '&expName=' + \
          expName + '&state=autoLogout"')
    print('</script>')
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.getDays">
    <p>def <span class="ident">getDays</span>(</p><p>self, kinst, year, month=None, optimize=True)</p>
    </div>
    

    
  
    <div class="desc"><p>getDays returns a sorted list of datetime.date objects where
there is local data for kinst &amp; year &amp; possibly month combination</p>
<p>Inputs:
    kinst - instrument id (int)
    year - year (int)
    month (1-12) if None, include all months
    optimize - if True, only start search at beginning of year.  But may miss long experiments,
        so if optimization if False, starts at beginning</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.getDays', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.getDays" class="source">
    <pre><code>def getDays(self, kinst, year, month=None, optimize=True):
    """getDays returns a sorted list of datetime.date objects where
    there is local data for kinst & year & possibly month combination
    
    Inputs:
        kinst - instrument id (int)
        year - year (int)
        month (1-12) if None, include all months
        optimize - if True, only start search at beginning of year.  But may miss long experiments,
            so if optimization if False, starts at beginning
    """
    retList = []
    sDT = datetime.datetime(year,1,1)
    eDT = datetime.datetime(year,12,31,23,59,59)
    if self._madExpObjDate is None:
        self._madExpObjDate = madrigal.metadata.MadrigalExperiment(self._madDB)
    if optimize:
        startIndex = self._madExpObjDate.getStartPosition(sDT)
    else:
        startIndex = 0
    for i in range(startIndex, self._madExpObjDate.getExpCount()):
        thisKinst = self._madExpObjDate.getKinstByPosition(i)
        if kinst != thisKinst:
            continue
        thisSDTList = self._madExpObjDate.getExpStartDateTimeByPosition(i)
        thisSDT = datetime.datetime(*thisSDTList[0:6])
        thisEDTList = self._madExpObjDate.getExpEndDateTimeByPosition(i)
        thisEDT = datetime.datetime(*thisEDTList[0:6])
        if thisEDT < sDT:
            continue
        if thisSDT > eDT:
            continue
        # check for security
        security = self._madExpObjDate.getSecurityByPosition(i)
        if not self.isTrusted():
            if security not in (0,2):
                continue
        else:
            if security not in (0,1,2,3):
                continue
        # loop over all days
        delta = datetime.timedelta(days=1)
        loopDT = max(sDT, datetime.datetime(thisSDT.year, thisSDT.month, thisSDT.day))
        while (loopDT <= thisEDT):
            if loopDT > eDT:
                break
            if not month is None:
                if month > loopDT.month:
                    loopDT += delta
                    continue
                elif month < loopDT.month:
                    break
            thisDate = loopDT.date()
            if thisDate not in retList:
                retList.append(thisDate)
            loopDT += delta
            
            
    retList.sort()
    return(retList)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.getExpIDFromExpPath">
    <p>def <span class="ident">getExpIDFromExpPath</span>(</p><p>self, expPath, matchAnyExpNum=False)</p>
    </div>
    

    
  
    <div class="desc"><p>getExpIDFromExpPath returns the expId for given expPath (starts with 'experiments')</p>
<p>If matchAnyExpNum is False, it will only match the right experiments<em> directory (default).
It True, matches via re to experiments[0-9]</em>/<remaining exp path></p>
<p>Returns None if not found</p>
<p>Inputs:
    expPath - experiment path (starts with 'experiments')</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.getExpIDFromExpPath', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.getExpIDFromExpPath" class="source">
    <pre><code>def getExpIDFromExpPath(self, expPath, matchAnyExpNum=False):
    """getExpIDFromExpPath returns the expId for given expPath (starts with 'experiments')
    
    If matchAnyExpNum is False, it will only match the right experiments* directory (default).
    It True, matches via re to experiments[0-9]*/<remaining exp path>
    
    Returns None if not found
    
    Inputs:
        expPath - experiment path (starts with 'experiments')
    """
    madExpObj = madrigal.metadata.MadrigalExperiment(self._madDB)
    if matchAnyExpNum:
        expPathRE = 'experiments[0-9]*/' + expPath[expPath.find('/')+1:]
    for i in range(madExpObj.getExpCount()):
        if not matchAnyExpNum:
            if madExpObj.getExpPathByPosition(i) == expPath:
                return(madExpObj.getExpIdByPosition(i))
        else:
            if len(re.findall(expPathRE, madExpObj.getExpPathByPosition(i))) > 0:
                return(madExpObj.getExpIdByPosition(i))
    
    return(None)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.getExpInfoFromExpID">
    <p>def <span class="ident">getExpInfoFromExpID</span>(</p><p>self, expID)</p>
    </div>
    

    
  
    <div class="desc"><p>getExpInfoFromExpID returns a tuple of (pi_name, pi_email, expUrl, kinst, expDesc, kinstDesc) for given expID</p>
<p>expUrl is url from getRealExpUrlByExpId</p>
<p>Inputs:
    expID - experimentID (int)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.getExpInfoFromExpID', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.getExpInfoFromExpID" class="source">
    <pre><code>def getExpInfoFromExpID(self, expID):
    """getExpInfoFromExpID returns a tuple of (pi_name, pi_email, expUrl, kinst, expDesc, kinstDesc) for given expID
    
    expUrl is url from getRealExpUrlByExpId
    
    Inputs:
        expID - experimentID (int)
    """
    expID = int(expID)
    if self._madExpObjExpID is None:
        self._madExpObjExpID = madrigal.metadata.MadrigalExperiment(self._madDB)
    kinst = self._madExpObjExpID.getKinstByExpId(expID)
    kinstDesc = self._instObj.getInstrumentName(kinst)
    expPI = self._madExpObjExpID.getPIByExpId(expID)
    expPIEmail = self._madExpObjExpID.getPIEmailByExpId(expID)
    expUrl = self._madExpObjExpID.getRealExpUrlByExpId(expID)
    if expPI in (None, ''):
        expPI = self._instObj.getContactName(kinst)
        expPIEmail = self._instObj.getContactEmail(kinst)
    thisSDTList = self._madExpObjExpID.getExpStartDateTimeByExpId(expID)
    thisSDT = datetime.datetime(*thisSDTList[0:6])
    thisEDTList = self._madExpObjExpID.getExpEndDateTimeByExpId(expID)
    thisEDT = datetime.datetime(*thisEDTList[0:6])
    thisExpName = self._madExpObjExpID.getExpNameByExpId(expID)
    thisExpDesc = '%s: %s-%s' % (thisExpName, thisSDT.strftime('%Y-%m-%d %H:%M:%S'),
                                 thisEDT.strftime('%Y-%m-%d %H:%M:%S'))
    
    return((expPI, expPIEmail, expUrl, kinst, thisExpDesc, kinstDesc))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.getExperimentList">
    <p>def <span class="ident">getExperimentList</span>(</p><p>self, kinstList, startDT, endDT, localOnly)</p>
    </div>
    

    
  
    <div class="desc"><p>getExperimentList returns a sorted list of tuples of (expId, expUrl, expName, instName, kinst, 
expStartDT, expEndDT, siteId, siteName)</p>
<p>Inputs:
    kinstList -  a list of instrument id (int) - may include 0
    startDT - start datetime to search
    endDT - end datetime to search
    localOnly - if True, only search locally. If False, search globally</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.getExperimentList', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.getExperimentList" class="source">
    <pre><code>def getExperimentList(self, kinstList, startDT, endDT, localOnly):
    """getExperimentList returns a sorted list of tuples of (expId, expUrl, expName, instName, kinst, 
    expStartDT, expEndDT, siteId, siteName)
    
    Inputs:
        kinstList -  a list of instrument id (int) - may include 0
        startDT - start datetime to search
        endDT - end datetime to search
        localOnly - if True, only search locally. If False, search globally
    """
    retList = []
    madroot = self._madDB.getMadroot()
    siteId = self._madDB.getSiteID()
    siteObj = madrigal.metadata.MadrigalSite(self._madDB)
    if localOnly:
        expTabFile = os.path.join(madroot, 'metadata/expTab.txt')
    else:
        expTabFile = os.path.join(madroot, 'metadata/expTabAll.txt')
    madExpObjDate = madrigal.metadata.MadrigalExperiment(self._madDB, expTabFile)
    startIndex = madExpObjDate.getStartPosition(startDT)
    for i in range(startIndex, madExpObjDate.getExpCount()):
        thisKinst = madExpObjDate.getKinstByPosition(i)
        if thisKinst not in kinstList and 0 not in kinstList:
            continue
        thisSDTList = madExpObjDate.getExpStartDateTimeByPosition(i)
        thisSDT = datetime.datetime(*thisSDTList[0:6])
        thisEDTList = madExpObjDate.getExpEndDateTimeByPosition(i)
        thisEDT = datetime.datetime(*thisEDTList[0:6])
        if thisEDT < startDT:
            continue
        if thisSDT > endDT:
            break
        # check for security
        security = madExpObjDate.getSecurityByPosition(i)
        if not self.isTrusted():
            if security not in (0,2):
                continue
        else:
            if security not in (0,1,2,3):
                continue
        thisSiteId = madExpObjDate.getExpSiteIdByPosition(i)
        if siteId == thisSiteId:
            isLocal = True
        else:
            isLocal = False
        thisExpId = madExpObjDate.getExpIdByPosition(i)
        thisExpPath = madExpObjDate.getExpPathByPosition(i)
        thisExpName = madExpObjDate.getExpNameByPosition(i)
        if isLocal:
            thisExpUrl = django.urls.reverse('show_experiment') + \
                '?experiment_list=%i' % (thisExpId)
        elif siteObj.getSiteVersion(thisSiteId) == '2.6':
            thisExpUrl = 'http://' + os.path.join(siteObj.getSiteServer(thisSiteId),
                                      siteObj.getSiteRelativeCGI(thisSiteId),
                                      'madExperiment.cgi?exp=%s' % (thisExpPath))
            thisExpUrl += '&displayLevel=0&expTitle=%s' % (django.utils.http.urlquote(thisExpName))
        else:
            # remote Madrigal 3.0 site
            baseUrl = os.path.basename(django.urls.reverse('show_experiment')[:-1])
            thisExpUrl = baseUrl + '?experiment_list=%s' % (thisExpPath)
            thisSiteUrl = 'http://%s' % (siteObj.getSiteServer(thisSiteId))
            relativeUrl = siteObj.getSiteDocRoot(thisSiteId)
            if relativeUrl not in ('', None):
                thisSiteUrl = os.path.join(thisSiteUrl, relativeUrl)
            if thisSiteUrl[-1] != '/' and thisExpUrl[0] != '/':
                thisSiteUrl += '/'
            thisExpUrl = thisSiteUrl + thisExpUrl
            
        thisSiteName = siteObj.getSiteName(thisSiteId)
        instName = self._instObj.getInstrumentName(thisKinst)
        
        retList.append((thisExpId, thisExpUrl, thisExpName, instName, thisKinst, 
                        thisSDT.strftime('%Y-%m-%d %H:%M:%S'), thisEDT.strftime('%Y-%m-%d %H:%M:%S'),
                        thisSiteId, thisSiteName))
            
    return(retList)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.getExpsOnDate">
    <p>def <span class="ident">getExpsOnDate</span>(</p><p>self, kinst, year, month, day, optimize=True)</p>
    </div>
    

    
  
    <div class="desc"><p>getExpsOnDate returns a sorted list of tuples of (expId, expDesc, expDir, pi_name, pi_email)</p>
<p>Inputs:
    kinst - instrument id (int)
    year - year (int)
    month - month (int)
    day - day (int)
    optimize - if True, only start search at beginning of day.  But may miss long experiments,
        so if optimization if False, starts at beginning</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.getExpsOnDate', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.getExpsOnDate" class="source">
    <pre><code>def getExpsOnDate(self, kinst, year, month, day, optimize=True):
    """getExpsOnDate returns a sorted list of tuples of (expId, expDesc, expDir, pi_name, pi_email)
    
    Inputs:
        kinst - instrument id (int)
        year - year (int)
        month - month (int)
        day - day (int)
        optimize - if True, only start search at beginning of day.  But may miss long experiments,
            so if optimization if False, starts at beginning
    """
    retList = []
    sDT = datetime.datetime(year,month,day)
    eDT = datetime.datetime(year,month,day,23,59,59)
    if self._madExpObjDate is None:
        self._madExpObjDate = madrigal.metadata.MadrigalExperiment(self._madDB)
    if optimize:
        startIndex = self._madExpObjDate.getStartPosition(sDT)
    else:
        startIndex = 0
    for i in range(startIndex, self._madExpObjDate.getExpCount()):
        thisKinst = self._madExpObjDate.getKinstByPosition(i)
        if kinst != thisKinst:
            continue
        thisSDTList = self._madExpObjDate.getExpStartDateTimeByPosition(i)
        thisSDT = datetime.datetime(*thisSDTList[0:6])
        thisEDTList = self._madExpObjDate.getExpEndDateTimeByPosition(i)
        thisEDT = datetime.datetime(*thisEDTList[0:6])
        if thisEDT < sDT:
            continue
        if thisSDT > eDT:
            continue
        # check for security
        security = self._madExpObjDate.getSecurityByPosition(i)
        if not self.isTrusted():
            if security not in (0,2):
                continue
        else:
            if security not in (0,1,2,3):
                continue
        thisExpId = self._madExpObjDate.getExpIdByPosition(i)
        thisExpName = self._madExpObjDate.getExpNameByPosition(i)
        thisExpDesc = '%s: %s-%s' % (thisExpName, thisSDT.strftime('%Y-%m-%d %H:%M:%S'),
                                     thisEDT.strftime('%Y-%m-%d %H:%M:%S'))
        thisExpDir = self._madExpObjDate.getExpDirByPosition(i)
        thisExpPI = self._madExpObjDate.getPIByPosition(i)
        thisExpPIEmail = self._madExpObjDate.getPIEmailByPosition(i)
        if thisExpPI in (None, ''):
            thisExpPI = self._instObj.getContactName(kinst)
            thisExpPIEmail = self._instObj.getContactEmail(kinst)
        retList.append((thisExpId, thisExpDesc, thisExpDir))
            
    return(retList)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.getFileFromExpDir">
    <p>def <span class="ident">getFileFromExpDir</span>(</p><p>self, expDir, kinst, includeNonDefault=False)</p>
    </div>
    

    
  
    <div class="desc"><p>getFileFromExpDir returns a list of tuples of (basename, fileDesc)</p>
<p>Inputs:
    expDir - full path to exp directory
    kinst - instrument id (used to look up kindat descriptions)
    includeNonDefault - if True, include variant and history files.  If False
        (the default), do not</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.getFileFromExpDir', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.getFileFromExpDir" class="source">
    <pre><code>def getFileFromExpDir(self, expDir, kinst, includeNonDefault=False):
    """getFileFromExpDir returns a list of tuples of (basename, fileDesc)
    
    Inputs:
        expDir - full path to exp directory
        kinst - instrument id (used to look up kindat descriptions)
        includeNonDefault - if True, include variant and history files.  If False
            (the default), do not
    """
    retList = []
    realTimeList = [] # in case no default files
    if not os.access(os.path.join(expDir, 'fileTab.txt'), os.R_OK):
        # no files in this experiment
        return(retList)
    madFileObj = madrigal.metadata.MadrigalMetaFile(self._madDB, os.path.join(expDir, 'fileTab.txt'))
    for i in range(madFileObj.getFileCount()):
        if madFileObj.getAccessByPosition(i) == 1 and not self.isTrusted():
            continue
        category = madFileObj.getCategoryByPosition(i)
        if category in (2,3) and not includeNonDefault:
            continue
        basename = madFileObj.getFilenameByPosition(i)
        kindat = madFileObj.getKindatByPosition(i)
        kindatDesc = self._madKindatObj.getKindatDescription(kindat, kinst)
        status = madFileObj.getStatusByPosition(i)
        fileDesc = '%s: %s - %s' % (basename, kindatDesc, status)
        if category != 4:
            retList.append((basename, fileDesc))
        else:
            realTimeList.append((basename, fileDesc))
        
    if len(retList) > 0:
        return(retList)
    else:
        return(realTimeList)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.getFileFromExpID">
    <p>def <span class="ident">getFileFromExpID</span>(</p><p>self, expID, includeNonDefault=False)</p>
    </div>
    

    
  
    <div class="desc"><p>getFileFromExpDir returns a list of tuples of (basename, fileDesc)</p>
<p>Inputs:
    expID - experimentID (int)
    includeNonDefault - if True, include variant and history files.  If False
        (the default), do not</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.getFileFromExpID', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.getFileFromExpID" class="source">
    <pre><code>def getFileFromExpID(self, expID, includeNonDefault=False):
    """getFileFromExpDir returns a list of tuples of (basename, fileDesc)
    
    Inputs:
        expID - experimentID (int)
        includeNonDefault - if True, include variant and history files.  If False
            (the default), do not
    """
    retList = []
    realTimeList = [] # in case no default files
    if self._madExpObjExpID is None:
        self._madExpObjExpID = madrigal.metadata.MadrigalExperiment(self._madDB)
    expDir = self._madExpObjExpID.getExpDirByExpId(expID)
    kinst = self._madExpObjExpID.getKinstByExpId(expID)
    
    if not os.access(os.path.join(expDir, 'fileTab.txt'), os.R_OK):
        # no files in this experiment
        return(retList)
    
    madFileObj = madrigal.metadata.MadrigalMetaFile(self._madDB, os.path.join(expDir, 'fileTab.txt'))
    for i in range(madFileObj.getFileCount()):
        if madFileObj.getAccessByPosition(i) == 1 and not self.isTrusted():
            continue
        category = madFileObj.getCategoryByPosition(i)
        if category in (2,3) and not includeNonDefault:
            continue
        if category == 2:
            categoryStr = '<variant file> '
        elif category == 3:
            categoryStr = '<history file> '
        else:
            categoryStr = ''
        basename = madFileObj.getFilenameByPosition(i)
        kindat = madFileObj.getKindatByPosition(i)
        kindatDesc = self._madKindatObj.getKindatDescription(kindat, kinst)
        status = madFileObj.getStatusByPosition(i)
        fileDesc = '%s: %s%s - %s' % (basename, categoryStr, kindatDesc, status)
        if category != 4:
            retList.append((basename, fileDesc))
        else:
            realTimeList.append((basename, fileDesc))
        
    if len(retList) > 0:
        return(retList)
    else:
        return(realTimeList)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.getInfoFromFile">
    <p>def <span class="ident">getInfoFromFile</span>(</p><p>self, filePath)</p>
    </div>
    

    
  
    <div class="desc"><p>getInfoFromFile returns a tuple of (expName, kindatDesc) for a given input file</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.getInfoFromFile', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.getInfoFromFile" class="source">
    <pre><code>def getInfoFromFile(self, filePath):
    """getInfoFromFile returns a tuple of (expName, kindatDesc) for a given input file
    """
    expDir = os.path.dirname(filePath)
    basename = os.path.basename(filePath)
    madExpObj = madrigal.metadata.MadrigalExperiment(self._madDB, os.path.join(expDir, 'expTab.txt'))
    expName = madExpObj.getExpNameByPosition(0)
    kinst = madExpObj.getKinstByPosition(0)
    madFileObj = madrigal.metadata.MadrigalMetaFile(self._madDB, os.path.join(expDir, 'fileTab.txt'))
    kindat = madFileObj.getKindatByFilename(basename)
    kindatDesc = self._madKindatObj.getKindatDescription(kindat, kinst)
    return((expName, kindatDesc))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.getMonths">
    <p>def <span class="ident">getMonths</span>(</p><p>self, kinst, year, optimize=True)</p>
    </div>
    

    
  
    <div class="desc"><p>getMonths returns a list of tuples of (monthNumber, monthName) where monthNumber
is 1-12, and monthName is the form January, Febuary, etc. for the the months where
there is local data for kinst &amp; year combination</p>
<p>Inputs:
    kinst - instrument id (int)
    year - year (int)
    optimize - if True, only start search at beginning of year.  But may miss long experiments,
        so if optimization if False, starts at beginning</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.getMonths', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.getMonths" class="source">
    <pre><code>def getMonths(self, kinst, year, optimize=True):
    """getMonths returns a list of tuples of (monthNumber, monthName) where monthNumber
    is 1-12, and monthName is the form January, Febuary, etc. for the the months where
    there is local data for kinst & year combination
    
    Inputs:
        kinst - instrument id (int)
        year - year (int)
        optimize - if True, only start search at beginning of year.  But may miss long experiments,
            so if optimization if False, starts at beginning
    """
    tempDict = {} # dict with key = month number, value = month name
    sDT = datetime.datetime(year,1,1)
    eDT = datetime.datetime(year,12,31,23,59,59)
    madroot = self._madDB.getMadroot()
    if self._madExpObjDate is None:
        self._madExpObjDate = madrigal.metadata.MadrigalExperiment(self._madDB)
    if optimize:
        startIndex = self._madExpObjDate.getStartPosition(sDT)
    else:
        startIndex = 0
    for i in range(startIndex, self._madExpObjDate.getExpCount()):
        thisKinst = self._madExpObjDate.getKinstByPosition(i)
        if kinst != thisKinst:
            continue
        thisSDTList = self._madExpObjDate.getExpStartDateTimeByPosition(i)
        thisSDT = datetime.datetime(*thisSDTList[0:6])
        thisEDTList = self._madExpObjDate.getExpEndDateTimeByPosition(i)
        thisEDT = datetime.datetime(*thisEDTList[0:6])
        if thisEDT < sDT:
            continue
        if thisSDT > eDT:
            continue
        # check for security
        security = self._madExpObjDate.getSecurityByPosition(i)
        if not self.isTrusted(): 
            if security not in (0,2):
                continue
        else:
            if security not in (0,1,2,3):
                continue
        if thisSDT.year == year:
            startMonth = thisSDT.month
        else:
            startMonth = 1
        if thisEDT.year == year:
            endMonth = thisEDT.month
        else:
            endMonth = 12
        monthList = list(range(startMonth, endMonth + 1))
        for thisMonth in monthList:
            if thisMonth not in list(tempDict.keys()):
                tempDict[thisMonth] = calendar.month_name[thisMonth]
            
    monthKeys = list(tempDict.keys())
    monthKeys.sort()
    retList = [(monthKey, tempDict[monthKey]) for monthKey in monthKeys]
    return(retList)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.getRulesOfTheRoad">
    <p>def <span class="ident">getRulesOfTheRoad</span>(</p><p>self, PI=None, PIEmail=None)</p>
    </div>
    

    
  
    <div class="desc"><p>getRulesOfTheRoad returns a string giving the rules in html formal for using madrigal data.</p>
<p>Inputs: PI - contact name. Default is site name.
    PIEmail - email link.  Default is site admin.</p>
<p>Returns: a string giving the rules in html formal for using madrigal data</p>
<p>Affects: None.</p>
<p>Exceptions: None.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.getRulesOfTheRoad', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.getRulesOfTheRoad" class="source">
    <pre><code>def getRulesOfTheRoad(self, PI=None, PIEmail=None):
    """ getRulesOfTheRoad returns a string giving the rules in html formal for using madrigal data.
    Inputs: PI - contact name. Default is site name.
        PIEmail - email link.  Default is site admin.
    
    Returns: a string giving the rules in html formal for using madrigal data
    Affects: None.
    Exceptions: None.
    """
    if not PI or not PIEmail:
        # get the site name
        siteObj = madrigal.metadata.MadrigalSite(self._madDB)
        siteID = self._madDB.getSiteID()
        contactName = str(siteObj.getSiteName(siteID))
        contactEmail = str(siteObj.getSiteEmail(siteID))
    else:
        contactName = str(PI)
        contactEmail = str(PIEmail)
    
    returnStr = 'Please contact %s at ' % (contactName)
    returnStr = returnStr + '<a href="mailto:' + contactEmail + '">' + \
                contactEmail + '</a> before using this data in a report or publication.'
    return returnStr
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.getSingleRedirectList">
    <p>def <span class="ident">getSingleRedirectList</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>getSingleRedirectList returns a list with tuples (kinst, url) where url is url to redirect single UI
to if instrument not local. If no redirect needed because instrument local, url is empty string</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.getSingleRedirectList', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.getSingleRedirectList" class="source">
    <pre><code>def getSingleRedirectList(self):
    """getSingleRedirectList returns a list with tuples (kinst, url) where url is url to redirect single UI
    to if instrument not local. If no redirect needed because instrument local, url is empty string
    """
    madInstData = madrigal.metadata.MadrigalInstrumentData(self._madDB, True)
    siteObj = madrigal.metadata.MadrigalSite(self._madDB)
    siteID = self._madDB.getSiteID()
    
    # create a dict with key = siteID, value = redirect url for speed
    getStr = '?isGlobal=True&categories=%i&instruments=%i'
    addUrl = django.urls.reverse('view_single')
    cedarUrl = 'http://cedar.openmadrigal.org/' + addUrl + getStr
    siteDict = {}
    for thisSiteID, siteDesc in siteObj.getSiteList():
        if thisSiteID == siteID:
            siteDict[thisSiteID] = '' # local case
        elif siteObj.getSiteVersion(thisSiteID) == '2.6':
            # redirect to cedar because other site below Madrigal 3
            siteDict[thisSiteID] = cedarUrl
        else:
            siteDict[thisSiteID] = 'http://' + siteObj.getSiteServer(thisSiteID)
            secondPart = siteObj.getSiteDocRoot(thisSiteID) + addUrl + getStr
            if secondPart[0] == '/':
                siteDict[thisSiteID] += secondPart
            else:
                siteDict[thisSiteID] += '/' + secondPart
    
    
    retList = []
    for kinst, desc, thisSiteID in madInstData.getInstruments():
        if len(siteDict[thisSiteID]) > 0:
            if siteDict[thisSiteID].find('=%i') != -1:
                url = siteDict[thisSiteID] % (self._instObj.getCategoryId(kinst), kinst)
            else:
                url = siteDict[thisSiteID]
        else:
            url = ''
        retList.append((kinst, url))
        
    return(retList)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.getSiteInfo">
    <p>def <span class="ident">getSiteInfo</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>getSiteInfo returns a tuple of two items:
1. local site name
2. list of tuples of (siteName, url) of non-local sites</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.getSiteInfo', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.getSiteInfo" class="source">
    <pre><code>def getSiteInfo(self):
    """getSiteInfo returns a tuple of two items:
        1. local site name
        2. list of tuples of (siteName, url) of non-local sites
    """
    siteID = self._madDB.getSiteID()
    siteObj = madrigal.metadata.MadrigalSite(self._madDB)
    siteName = siteObj.getSiteName(siteID)
    retList = []
    siteList = siteObj.getSiteList()
    for thisSiteID, thisSiteName in siteList:
        if thisSiteID == siteID:
            continue
        thisSiteServer = siteObj.getSiteServer(thisSiteID)
        thisSiteDocRoot = siteObj.getSiteDocRoot(thisSiteID)
        thisSiteUrl = urllib.parse.urlunparse(('http', thisSiteServer, thisSiteDocRoot, '','',''))
        retList.append((thisSiteName, thisSiteUrl))
    return((siteName, retList))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.isTrusted">
    <p>def <span class="ident">isTrusted</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>isTrusted returns 1 if browser ip matches any in the trustedIPs.txt file; 0 otherwise.</p>
<p>Inputs: None</p>
<p>Returns: 1 if browser ip matches any in the trustedIPs.txt file; 0 otherwise.  Also returns
0 if no browser ip available or trustedIPs.txt cannot be opened.</p>
<p>Affects: None.</p>
<p>Exceptions: None.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.isTrusted', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.isTrusted" class="source">
    <pre><code>def isTrusted(self):
    """ isTrusted returns 1 if browser ip matches any in the trustedIPs.txt file; 0 otherwise.
    Inputs: None
    
    Returns: 1 if browser ip matches any in the trustedIPs.txt file; 0 otherwise.  Also returns
    0 if no browser ip available or trustedIPs.txt cannot be opened.
    Affects: None.
    Exceptions: None.
    """
    if self._isTrusted_ != None:
        return(self._isTrusted_)
    
    try:
        trustFile = open(self._madDB.getMadroot() + '/trustedIPs.txt', 'r')
    except:
        return 0
    # try to read env var REMOTE_ADDR and HTTP_X_FORWARDED_FOR
    userIPList = []
    if os.environ.get('REMOTE_ADDR')!= None:
        userIPList.append(os.environ.get('REMOTE_ADDR'))
    if os.environ.get('HTTP_X_FORWARDED_FOR') != None:
        ips = os.environ.get('HTTP_X_FORWARDED_FOR').split(',')
        for ip in ips:
            userIPList.append(ip.strip())
    if len(userIPList) == 0:
        self._isTrusted_ = 0
        return 0
    if len(userIPList[0]) < 7:
        # ip address too short
        self._isTrusted_ = 0
        return 0
    # loop through trustedIPs.txt to find a match
    ipList = trustFile.readlines()
    for userIP in userIPList:
        for ipItem in ipList:
            # match using filename matching with *
            if fnmatch.fnmatch(userIP, ipItem.strip()):
                self._isTrusted_ = 1
                return 1
    # out of loop, no match found
    self._isTrusted_ = 0
    return 0
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.listRecords">
    <p>def <span class="ident">listRecords</span>(</p><p>self, fullFilename)</p>
    </div>
    

    
  
    <div class="desc"><p>listRecords returns the list records html for fullFilename</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.listRecords', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.listRecords" class="source">
    <pre><code>def listRecords(self, fullFilename):
    """listRecords returns the list records html for fullFilename
    """
    # check if record plots exist
    basename = os.path.basename(fullFilename)
    thisDir = os.path.dirname(fullFilename)
    pngFiles = glob.glob(os.path.join(thisDir, 'plots', basename, 'records/*.png'))
    if len(pngFiles) > 0:
        url = '<a href="javascript:plotRecno(%i)">View record plot</a>'
    else:
        url = None
    
    output = os.path.join(tempfile.gettempdir(), 'tmp_%i.txt' % (random.randint(0,999999)))
    
    madrigal.cedar.listRecords(fullFilename, output, url)
    
    f = open(output)
    text = f.read()
    f.close()
    os.remove(output)
    return(text.strip())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.logDataAccess">
    <p>def <span class="ident">logDataAccess</span>(</p><p>self, fullFilenameList, user_fullname=None, user_email=None, user_affiliation=None)</p>
    </div>
    

    
  
    <div class="desc"><p>logDataAccess logs queries that access low-level data.</p>
<p>Records user name, email, affiliation, datetime, and full path the file(s) accessed.</p>
<p>Inputs:</p>
<pre><code>fullFilenameList either a list of full filenames, or a string with one filename

user_fullname - if None, try to read from cookie.  Also, any commas replaced by spaces.

user_email - if None, try to read from cookie.  Also, any commas replaced by spaces.

user_affiliation - if None, try to read from cookie.  Also, any commas replaced by spaces.
</code></pre>
<p>Outputs: None</p>
<p>Affects: Write line to log file with 5 or more comma-delimited columns.  Example:</p>
<pre><code>Bill Rideout,brideout@haystack.mit.edu,MIT Haystack,2002-12-25 00:00:00,             /opt/madrigal/experiments/2005/mlh/01sep05/mlh050901g.001,/opt/madrigal/experiments/2005/mlh/02sep05/mlh050902g.001
</code></pre>
<p>Uses _getLock and _dropLock to ensure single users access to log file</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.logDataAccess', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.logDataAccess" class="source">
    <pre><code>def logDataAccess(self, fullFilenameList, user_fullname=None, user_email=None, user_affiliation=None):
    """ logDataAccess logs queries that access low-level data.
    Records user name, email, affiliation, datetime, and full path the file(s) accessed.
    Inputs:
        fullFilenameList either a list of full filenames, or a string with one filename
        user_fullname - if None, try to read from cookie.  Also, any commas replaced by spaces.
        user_email - if None, try to read from cookie.  Also, any commas replaced by spaces.
        user_affiliation - if None, try to read from cookie.  Also, any commas replaced by spaces.
        
    Outputs: None
    Affects: Write line to log file with 5 or more comma-delimited columns.  Example:
        Bill Rideout,brideout@haystack.mit.edu,MIT Haystack,2002-12-25 00:00:00, \
        /opt/madrigal/experiments/2005/mlh/01sep05/mlh050901g.001,/opt/madrigal/experiments/2005/mlh/02sep05/mlh050902g.001
    Uses _getLock and _dropLock to ensure single users access to log file
    """
    if user_fullname == None or user_email == None or user_affiliation == None:
    
        # try to get name, email, affiliation from cookie
        cookie = http.cookies.SimpleCookie()
        if 'HTTP_COOKIE' in os.environ:
            cookie.load(os.environ['HTTP_COOKIE'])
            try:
                user_fullname = cookie["user_fullname"].value
                user_email = cookie["user_email"].value
                user_affiliation = cookie["user_affiliation"].value
            except:
                # no way to write log
                return
        if user_fullname == None or user_email == None or user_affiliation == None:
            return
    # strip out any commas
    user_fullname = user_fullname.replace(',', ' ')
    user_email = user_email.replace(',', ' ')
    user_affiliation = user_affiliation.replace(',', ' ')
    if type(fullFilenameList) in (list, tuple):
        delimiter = ','
        fileStr = delimiter.join(fullFilenameList)
    else:
        fileStr = str(fullFilenameList)
    
    now = datetime.datetime.now()
    nowStr = now.strftime('%Y-%m-%d %H-%M-%S')
    # lock out any method that writes to log file
    self._getLock(self._logFile)
    f = open(self._logFile, 'a')
    f.write('%s,%s,%s,%s,%s\n' % (user_fullname.encode('utf8'),
                                  user_email.encode('utf8'),
                                  user_affiliation.encode('utf8'),
                                  nowStr,
                                  fileStr))
    f.close()
    # done with log file - allow access to other writing calls
    self._dropLock(self._logFile)  
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.modifyBasename">
    <p>def <span class="ident">modifyBasename</span>(</p><p>self, basename)</p>
    </div>
    

    
  
    <div class="desc"><p>modifyBasename adds _<num> to make sure basename unique</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.modifyBasename', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.modifyBasename" class="source">
    <pre><code>def modifyBasename(self, basename):
    """modifyBasename adds _<num> to make sure basename unique
    """
    base, file_extension = os.path.splitext(basename)
    index = base.rfind('_')
    if index != -1:
        try:
            length = len(base[index+1:])
            version = int(base[index+1:])
            # in case of overflow
            length = max(length, len(str(version + 1)))
            format = '%%0%ii' % (length)
            return('%s_%s%s' % (base[:index], format % (version + 1), file_extension))
        except:
            pass
    return('%s_%i%s' % (base, 1, file_extension))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.printFileAsIs">
    <p>def <span class="ident">printFileAsIs</span>(</p><p>self, fullFilename, user_fullname, user_email, user_affiliation, html=True)</p>
    </div>
    

    
  
    <div class="desc"><p>printFileAsIs returns the full path to a temp file representing file as plain text or html to print as is (that is, with parms rom file, and no filters)</p>
<p>Inputs:
    fullFilename - full path to Madrigal Hdf5 file to convert to string
    user_fullname, user_email, user_affiliation - user identification strings
    html - if True (the default) return as Html with popup parm names.  If False, pure text</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.printFileAsIs', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.printFileAsIs" class="source">
    <pre><code>def printFileAsIs(self, fullFilename, user_fullname, user_email, user_affiliation, html=True):
    """printFileAsIs returns the full path to a temp file representing file as plain text or html to print as is (that is, with parms rom file, and no filters)
    
    Inputs:
        fullFilename - full path to Madrigal Hdf5 file to convert to string
        user_fullname, user_email, user_affiliation - user identification strings
        html - if True (the default) return as Html with popup parm names.  If False, pure text
    """
    self.cleanStage()
    
    # create tmp dir if needed
    tmpDir = os.path.join(self._madDB.getMadroot(), 'experiments/stage')
    try:
        os.mkdir(tmpDir)
    except:
        pass
    
    fileName, fileExtension = os.path.splitext(fullFilename)
    fullTmpFilename = os.path.join(tmpDir, os.path.basename(fileName + '.txt'))
    if os.access(fullTmpFilename, os.R_OK):
        try:
            os.remove(fullTmpFilename)
        except:
            pass
    if html:
        summary = 'html'
    else:
        summary = 'plain'
    madrigal.cedar.convertToText(fullFilename, fullTmpFilename, summary=summary)
            
    # log access
    self.logDataAccess(fullFilename, user_fullname, user_email, user_affiliation)
    
    return(fullTmpFilename)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.runLookerFromForm">
    <p>def <span class="ident">runLookerFromForm</span>(</p><p>self, form)</p>
    </div>
    

    
  
    <div class="desc"><p>runLookerFromForm returns the text output of looker from one of the looker forms</p>
<p>Inputs:
    form - the django form that encapsulates all information from looker web page.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.runLookerFromForm', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.runLookerFromForm" class="source">
    <pre><code>def runLookerFromForm(self, form):
    """runLookerFromForm returns the text output of looker from one of the looker forms
    
    Inputs:
        form - the django form that encapsulates all information from looker web page.  
    """
    looker_cmd = os.path.join(self._madDB.getMadroot(), 'bin/looker1')
    looker_options = int(form['looker_options'])
    if looker_options in (1,2):
        try:
            kinst = int(form['instruments'])
            if kinst == 0:
                raise ValueError('')
            slatgd = self._instObj.getLatitude(kinst)
            slon = self._instObj.getLongitude(kinst)
            if slon > 180.0:
                slon -= 360.0
            saltgd = self._instObj.getAltitude(kinst)
        except:
            slatgd = float(form['inst_lat'])
            slon = float(form['inst_lon'])
            saltgd = float(form['inst_alt'])
        try:
            year = float(form['year'])
        except:
            year = 2000.0
        argStr = ' %i ' + '%f ' * 13
        argStr = argStr % (looker_options, year, slatgd, slon, saltgd,
                           float(form['start_lat']), float(form['stop_lat']), float(form['step_lat']),
                           float(form['start_lon']), float(form['stop_lon']), float(form['step_lon']),
                           float(form['start_alt']), float(form['stop_alt']), float(form['step_alt']))
        looker_cmd += argStr
        try:
            text = subprocess.check_output(looker_cmd.split())
        except:
            raise IOError('Unable to run cmd <%s>' % (looker_cmd))
        if type(text) == bytes:
            text = text.decode('utf-8')
        return(text)
    
    elif looker_options in (3,):
        try:
            year = float(form['year'])
        except:
            year = 2000.0
        argStr = ' %i ' + '%f ' * 13
        argStr = argStr % (looker_options, year, 0.0, 0.0, 0.0,
                           float(form['start_lat']), float(form['stop_lat']), float(form['step_lat']),
                           float(form['start_lon']), float(form['stop_lon']), float(form['step_lon']),
                           float(form['start_alt']), float(form['stop_alt']), float(form['step_alt']))
        looker_cmd += argStr
        text = subprocess.check_output(looker_cmd.split())
        if type(text) == bytes:
            text = text.decode('utf-8')
        return(text)
    elif looker_options in (4,):
        try:
            kinst = int(form['instruments'])
            if kinst == 0:
                raise ValueError('')
            slatgd = self._instObj.getLatitude(kinst)
            slon = self._instObj.getLongitude(kinst)
            if slon > 180.0:
                slon -= 360.0
            saltgd = self._instObj.getAltitude(kinst)
        except:
            slatgd = float(form['inst_lat'])
            slon = float(form['inst_lon'])
            saltgd = float(form['inst_alt'])
        try:
            year = float(form['year'])
        except:
            year = 2000.0
        argStr = ' %i ' + '%f ' * 13
        argStr = argStr % (looker_options, year, slatgd, slon, saltgd,
                           float(form['start_az']), float(form['stop_az']), float(form['step_az']),
                           float(form['start_el']), float(form['stop_el']), float(form['step_el']),
                           float(form['start_range']), float(form['stop_range']), float(form['step_range']))
        looker_cmd += argStr
        text = subprocess.check_output(looker_cmd.split())
        if type(text) == bytes:
            text = text.decode('utf-8')
        return(text)
    elif looker_options in (5,6,7):
        try:
            kinst = int(form['instruments'])
            if kinst == 0:
                raise ValueError('')
            slatgd = self._instObj.getLatitude(kinst)
            slon = self._instObj.getLongitude(kinst)
            if slon > 180.0:
                slon -= 360.0
            saltgd = self._instObj.getAltitude(kinst)
        except:
            slatgd = float(form['inst_lat'])
            slon = float(form['inst_lon'])
            saltgd = float(form['inst_alt'])
        try:
            year = float(form['year'])
        except:
            year = 2000.0
        argStr = ' %i ' + '%f ' * 13
        if looker_options == 5:
            p1 = float(form['fl_az'])
            p2 = float(form['fl_el'])
            p3 = float(form['fl_range'])
        elif looker_options == 6:
            p1 = float(form['fl_lat'])
            p2 = float(form['fl_lon'])
            p3 = float(form['fl_alt'])
        elif looker_options == 7:
            p1 = float(form['fl_apex_lat'])
            p2 = float(form['fl_apex_lon'])
            p3 = 0.0
        argStr = argStr % (looker_options, year, slatgd, slon, saltgd,
                           p1, p2, p3,
                           float(form['start_alt']), float(form['stop_alt']), float(form['step_alt']),
                           0.0, 0.0, 0.0)
        looker_cmd += argStr
        text = subprocess.check_output(looker_cmd.split())
        if type(text) == bytes:
            text = text.decode('utf-8')
        return(text)
    elif looker_options in (8,):
        latList = numpy.arange(float(form['start_lat']), float(form['stop_lat']), float(form['step_lat']))
        latList = latList.tolist()
        # check for null list
        if len(latList) == 0 and abs(float(form['start_lat']) - float(form['stop_lat'])) < 1.0E-6:
            latList = [float(form['start_lat'])]
        lonList = numpy.arange(float(form['start_lon']), float(form['stop_lon']), float(form['step_lon']))
        lonList = lonList.tolist()
        # check for null list
        if len(lonList) == 0 and abs(float(form['start_lon']) - float(form['stop_lon'])) < 1.0E-6:
            lonList = [float(form['start_lon'])]
        altList = numpy.arange(float(form['start_alt']), float(form['stop_alt']), float(form['step_alt']))
        altList = altList.tolist()
        # check for null list
        if len(altList) == 0 and abs(float(form['start_alt']) - float(form['stop_alt'])) < 1.0E-6:
            altList = [float(form['start_alt'])]
        requestedParms = ['gdlat', 'glon', 'gdalt'] + [str(parm.lower()) for parm in form['pList']]
        dtList = [form['datetime']]
        output = os.path.join(tempfile.gettempdir(), 'tmp_%i.txt' % (random.randint(0,999999)))
        madrigal.isprint.MadCalculatorGrid(output, requestedParms, dtList, latList, lonList, altList)
        f = open(output)
        text = f.read()
        f.close()
        os.remove(output)
        if type(text) == bytes:
            text = text.decode('utf-8')
        return(text.strip())
        
    else:
        raise ValueError('Unknown looker_options %s' % (str(looker_options)))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWeb.runMadrigalCalculatorFromForm">
    <p>def <span class="ident">runMadrigalCalculatorFromForm</span>(</p><p>self, madCalculatorForm)</p>
    </div>
    

    
  
    <div class="desc"><p>runMadrigalCalculatorFromForm returns the text output of madCalculator from the MadCalulatorForm</p>
<p>Inputs:
    madCalculatorForm - the django form that encapsulates all information from madrigal_calculator web page.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWeb.runMadrigalCalculatorFromForm', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWeb.runMadrigalCalculatorFromForm" class="source">
    <pre><code>def runMadrigalCalculatorFromForm(self, madCalculatorForm):
    """runMadrigalCalculatorFromForm returns the text output of madCalculator from the MadCalulatorForm
    
    Inputs:
        madCalculatorForm - the django form that encapsulates all information from madrigal_calculator web page.  
    """
    requestedParms = madCalculatorForm['parameters']
    requestedParms = ['gdlat', 'glon', 'gdalt'] + [str(parm) for parm in requestedParms]
    thisDT = madCalculatorForm['datetime']
    
    min_latitude = madCalculatorForm['min_latitude']
    max_latitude = madCalculatorForm['max_latitude']
    delta_latitude = madCalculatorForm['delta_latitude']
    
    min_longitude = madCalculatorForm['min_longitude']
    max_longitude = madCalculatorForm['max_longitude']
    delta_longitude = madCalculatorForm['delta_longitude']
    
    min_altitude = madCalculatorForm['min_altitude']
    max_altitude = madCalculatorForm['max_altitude']
    delta_altitude = madCalculatorForm['delta_altitude']
    
    latList = numpy.arange(min_latitude, max_latitude+0.001*delta_latitude, delta_latitude).tolist()
    lonList = numpy.arange(min_longitude, max_longitude+0.001*delta_longitude, delta_longitude).tolist()
    altList = numpy.arange(min_altitude, max_altitude+0.001*delta_altitude, delta_altitude).tolist()
    
    if 0 in (len(latList), len(lonList), len(altList)):
        raise ValueError('Got 0 length spatial range')
    
    output = os.path.join(tempfile.gettempdir(), 'tmp_%i.txt' % (random.randint(0,999999)))
    
    madrigal.isprint.MadCalculatorGrid(output, requestedParms, [thisDT], latList, lonList, altList)
    
    f = open(output)
    text = f.read()
    f.close()
    os.remove(output)
    return(text.strip())
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="madrigal.ui.web.MadrigalWebFormat" class="name">class <span class="ident">MadrigalWebFormat</span></p>
      
  
    <div class="desc"><p>MadrigalWebFormat defines the format of an web interface.</p>
<p>Information about how a web page is formatted is stored in this class.  In particular,
the possible derived parameters to display for a given format (such as Short or
Comprehensive) are set in this class.  Edit this class to create new formats or
modify existing ones.</p>
<p>Non-standard Python modules used:
None</p>
<p>No exceptions thrown</p>
<p>Change history:</p>
<p>Written by "Bill Rideout":mailto:wrideout@haystack.mit.edu  Oct. 29, 2001</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWebFormat', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWebFormat" class="source">
    <pre><code>class MadrigalWebFormat:
    """MadrigalWebFormat defines the format of an web interface.

    Information about how a web page is formatted is stored in this class.  In particular,
    the possible derived parameters to display for a given format (such as Short or
    Comprehensive) are set in this class.  Edit this class to create new formats or
    modify existing ones.

    Non-standard Python modules used:
    None

    No exceptions thrown

    Change history:

    Written by "Bill Rideout":mailto:wrideout@haystack.mit.edu  Oct. 29, 2001
    """

    # constants

    # Edit this data to change which parameters to display
    # or to add new formats
    #
    #                   Format          Parameters      
    #                   ------          ----------  
    _privateDict =  {'Comprehensive':  [   'year',
                                            'month',
                                            'day',
					                        'bmonth',
					                        'bday',
                                            'hour',
                                            'min',
                                            'sec',
                                            'md',
                                            'dayno',
                                            'bhm',
                                            'bhhmmss',
                                            'ehhmmss',
                                            'uth',
                                            'b_uth',
                                            'ut',
                                            'ut1_unix',
                                            'ut2_unix',
                                            'beg_ut',
                                            'slt',
                                            'sltc',
                                            'fyear',
                                            'sunrise_hour',
                                            'sunset_hour',
                                            'conj_sunrise_h',
                                            'conj_sunset_h',
                                            'aplt',
                                            'julian_date',
                                            'gdalt',
                                            'range',
                                            'resl',
                                            'azm',
                                            'az1',
                                            'az2',
                                            'elm',
                                            'el1',
                                            'el2',
                                            'gdlat',
                                            'glon',
                                            'szen',
                                            'szenc',
                                            'sdwht',
                                            'beamid',
                                            'bn',
                                            'be',
                                            'bd',
                                            'magh',
                                            'magd',
                                            'magzu',
                                            'bmag',
                                            'bdec',
                                            'binc',
                                            'lshell',
                                            'diplat',
                                            'invlat',
                                            'aplat',
                                            'aplon',
                                            'e_reg_s_lat',
                                            'e_reg_s_lon',
                                            'e_reg_s_sdwht',
                                            'e_reg_n_lat',
                                            'e_reg_n_lon',
                                            'e_reg_n_sdwht',
                                            'magconjlat',
                                            'magconjlon',
                                            'magconjsdwht',
                                            'mlt',
                                            'tsyg_eq_xgsm',
                                            'tsyg_eq_ygsm',
                                            'tsyg_eq_xgse',
                                            'tsyg_eq_ygse',
                                            'aacgm_lat',
                                            'aacgm_long',
                                            'aspect',
                                            'cxr',
                                            'cyr',
                                            'czr',
                                            'pl',
                                            'snp3',
                                            'chisq',
                                            'gfit',
                                            'mhdqc1',
                                            'systmp',
                                            'systmi',
                                            'power',
                                            'tfreq',
                                            'popl',
                                            'ne',
                                            'nel',
                                            'ti',
                                            'te',
                                            'tr',
                                            'vo',
                                            'ph+',
                                            'pm',
                                            'co',
                                            'vdopp',
                                            'dvdopp',
                                            'dco',
                                            'dpm',
                                            'dph+',
                                            'dvo',
                                            'dtr',
                                            'dte',
                                            'dti',
                                            'dpopl',
                                            'dne',
                                            'ne_model',
                                            'nel_model',
                                            'te_model',
                                            'ti_model',
                                            'vo_model',
                                            'hmax_model',
                                            'nmax_model',
                                            'ne_modeldiff',
                                            'nel_modeldiff',
                                            'te_modeldiff',
                                            'ti_modeldiff',
                                            'vo_modeldiff',
                                            'tn',
                                            'tnm',
                                            'tinfm',
                                            'mol',
                                            'nn2l',
                                            'no2l',
                                            'nol',
                                            'narl',
                                            'nhel',
                                            'nhl',
                                            'nn4sl',
                                            'fa',
                                            'pnrmd',
                                            'pnrmdi',
                                            'ut1',
                                            'ut2',
                                            'dut21',
                                            'kinst',
                                            'recno',
                                            'kindat',
                                            'fof2',
                                            'dfa',
                                            'dst',
                                            'kp',
                                            'ap',
                                            'ap3',
                                            'f10.7',
                                            'fbar',
                                            'pdcon',
                                            'dpdcon',
                                            'hlcon',
                                            'dhlcon',
                                            'ne_iri',
                                            'nel_iri',
                                            'tn_iri',
                                            'te_iri',
                                            'ti_iri',
                                            'po+_iri',
                                            'pno+_iri',
                                            'po2+_iri',
                                            'phe+_iri',
                                            'ph+_iri',
                                            'pn+_iri',
                                            'bxgsm',
                                            'bygsm',
                                            'bzgsm',
                                            'bimf',
                                            'bxgse',
                                            'bygse',
                                            'bzgse',
                                            'swden',
                                            'swspd',
                                            'swq'],
                      'Short':          [   'year',
                                            'md',
                                            'dayno',
                                            'uth',
                                            'b_uth',
                                            'ut',
                                            'beg_ut',
                                            'lt',
                                            'aplt',
                                            'jdayno',
                                            'gdalt',
                                            'range',
                                            'azm',
                                            'az1',
                                            'az2',
                                            'elm',
                                            'el1',
                                            'el2',
                                            'gdlat',
                                            'glon',
                                            'popl',
                                            'nel',
                                            'ti',
                                            'te',
                                            'tr',
                                            'vo',
                                            'ph+',
                                            'pm',
                                            'co',
                                            'vdopp',
                                            'dvdopp',
                                            'dco',
                                            'dpm',
                                            'dph+',
                                            'dvo',
                                            'dtr',
                                            'dte',
                                            'dti',
                                            'dpopl',
                                            'dne',
                                            'kp',
                                            'ap',
                                            'ap3',
                                            'f10.7',
                                            'fbar']}

    def getFormat(self, formatName):
        return self._privateDict[formatName]
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#madrigal.ui.web.MadrigalWebFormat">MadrigalWebFormat</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="madrigal.ui.web.MadrigalWebFormat.getFormat">
    <p>def <span class="ident">getFormat</span>(</p><p>self, formatName)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-madrigal.ui.web.MadrigalWebFormat.getFormat', this);">Show source &equiv;</a></p>
  <div id="source-madrigal.ui.web.MadrigalWebFormat.getFormat" class="source">
    <pre><code>def getFormat(self, formatName):
    return self._privateDict[formatName]
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
<table width="100%" border="1" cellpadding="0" cellspacing="2" class="navigation">
  <tr>
    <td width="5%"><a href="userData.m.html"><img src="/static/previous.png" alt="previous" width="32" height="32" border="0" /></a></td>
    <td width="5%"><a href="index.html"><img src="/static/up.png" alt="up" width="32" height="32" /></a></td>
    <td width="5%"><a href="../../dev_derivation.html"><img src="/static/next.png" alt="next" width="32" height="32" /></a></td>
    <td width="54%">madrigal.ui.web</td>
    <td width="13%"><a href="../../madContents.html">Doc home </a></td>
    <td width="18%"><a href="/">Madrigal home</a></td>
  </tr>
</table>
<div class='online-navigation'>
<b class="navlabel">Previous:</b>
<a class="sectref" href="userData.m.html">madrigal.ui.userData </A>
<b class="navlabel">&nbsp;&nbsp;Up:</b>
<a class="sectref" href="index.html">madrigal.ui</A>
<b class="navlabel">&nbsp;&nbsp;Next:</b>
<a class="sectref" href="../../dev_derivation.html">Madrigal derivation engine</A></div>
<hr/>
<p>&nbsp;</p>
</body>
</html>
